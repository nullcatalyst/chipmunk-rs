/* automatically generated by rust-bindgen */

pub const CP_USE_DOUBLES: u32 = 1;
pub const CP_BUFFER_BYTES: u32 = 32768;
pub const CP_MAX_CONTACTS_PER_ARBITER: u32 = 2;
pub const CP_VERSION_MAJOR: u32 = 7;
pub const CP_VERSION_MINOR: u32 = 0;
pub const CP_VERSION_RELEASE: u32 = 3;
extern "C" {
    pub fn cpMessage(
        condition: *const libc::c_char,
        file: *const libc::c_char,
        line: libc::c_int,
        isError: libc::c_int,
        isHardError: libc::c_int,
        message: *const libc::c_char,
        ...
    );
}
#[doc = " Chipmunk's floating point type."]
#[doc = " Can be reconfigured at compile time."]
pub type cpFloat = f64;
pub type cpHashValue = usize;
#[doc = " Type used internally to cache colliding object info for cpCollideShapes()."]
#[doc = " Should be at least 32 bits."]
pub type cpCollisionID = u32;
pub type cpBool = libc::c_uchar;
#[doc = " Type used for user data pointers."]
pub type cpDataPointer = *mut libc::c_void;
#[doc = " Type used for cpSpace.collision_type."]
pub type cpCollisionType = usize;
#[doc = " Type used for cpShape.group."]
pub type cpGroup = usize;
#[doc = " Type used for cpShapeFilter category and mask."]
pub type cpBitmask = libc::c_uint;
#[doc = " Type used for various timestamps in Chipmunk."]
pub type cpTimestamp = libc::c_uint;
#[doc = " Chipmunk's 2D vector type."]
#[doc = " @addtogroup cpVect"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cpVect {
    pub x: cpFloat,
    pub y: cpFloat,
}
#[test]
fn bindgen_test_layout_cpVect() {
    assert_eq!(
        ::core::mem::size_of::<cpVect>(),
        16usize,
        concat!("Size of: ", stringify!(cpVect))
    );
    assert_eq!(
        ::core::mem::align_of::<cpVect>(),
        8usize,
        concat!("Alignment of ", stringify!(cpVect))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cpVect>())).x as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(cpVect), "::", stringify!(x))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cpVect>())).y as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(cpVect), "::", stringify!(y))
    );
}
#[doc = " Column major affine transform."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cpTransform {
    pub a: cpFloat,
    pub b: cpFloat,
    pub c: cpFloat,
    pub d: cpFloat,
    pub tx: cpFloat,
    pub ty: cpFloat,
}
#[test]
fn bindgen_test_layout_cpTransform() {
    assert_eq!(
        ::core::mem::size_of::<cpTransform>(),
        48usize,
        concat!("Size of: ", stringify!(cpTransform))
    );
    assert_eq!(
        ::core::mem::align_of::<cpTransform>(),
        8usize,
        concat!("Alignment of ", stringify!(cpTransform))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cpTransform>())).a as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cpTransform),
            "::",
            stringify!(a)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cpTransform>())).b as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cpTransform),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cpTransform>())).c as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cpTransform),
            "::",
            stringify!(c)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cpTransform>())).d as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cpTransform),
            "::",
            stringify!(d)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cpTransform>())).tx as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cpTransform),
            "::",
            stringify!(tx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cpTransform>())).ty as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cpTransform),
            "::",
            stringify!(ty)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cpMat2x2 {
    pub a: cpFloat,
    pub b: cpFloat,
    pub c: cpFloat,
    pub d: cpFloat,
}
#[test]
fn bindgen_test_layout_cpMat2x2() {
    assert_eq!(
        ::core::mem::size_of::<cpMat2x2>(),
        32usize,
        concat!("Size of: ", stringify!(cpMat2x2))
    );
    assert_eq!(
        ::core::mem::align_of::<cpMat2x2>(),
        8usize,
        concat!("Alignment of ", stringify!(cpMat2x2))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cpMat2x2>())).a as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cpMat2x2),
            "::",
            stringify!(a)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cpMat2x2>())).b as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cpMat2x2),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cpMat2x2>())).c as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cpMat2x2),
            "::",
            stringify!(c)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cpMat2x2>())).d as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cpMat2x2),
            "::",
            stringify!(d)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cpArray {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cpHashSet {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cpBody {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cpShape {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cpCircleShape {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cpSegmentShape {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cpPolyShape {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cpConstraint {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cpPinJoint {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cpSlideJoint {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cpPivotJoint {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cpGrooveJoint {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cpDampedSpring {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cpDampedRotarySpring {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cpRotaryLimitJoint {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cpRatchetJoint {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cpGearJoint {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cpSimpleMotorJoint {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cpArbiter {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cpSpace {
    _unused: [u8; 0],
}
#[doc = " Chipmunk's axis-aligned 2D bounding box type. (left, bottom, right, top)"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cpBB {
    pub l: cpFloat,
    pub b: cpFloat,
    pub r: cpFloat,
    pub t: cpFloat,
}
#[test]
fn bindgen_test_layout_cpBB() {
    assert_eq!(
        ::core::mem::size_of::<cpBB>(),
        32usize,
        concat!("Size of: ", stringify!(cpBB))
    );
    assert_eq!(
        ::core::mem::align_of::<cpBB>(),
        8usize,
        concat!("Alignment of ", stringify!(cpBB))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cpBB>())).l as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(cpBB), "::", stringify!(l))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cpBB>())).b as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(cpBB), "::", stringify!(b))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cpBB>())).r as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(cpBB), "::", stringify!(r))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cpBB>())).t as *const _ as usize },
        24usize,
        concat!("Offset of field: ", stringify!(cpBB), "::", stringify!(t))
    );
}
#[doc = " Spatial index bounding box callback function type."]
#[doc = " The spatial index calls this function and passes you a pointer to an object you added"]
#[doc = " when it needs to get the bounding box associated with that object."]
pub type cpSpatialIndexBBFunc =
    ::core::option::Option<unsafe extern "C" fn(obj: *mut libc::c_void) -> cpBB>;
#[doc = " Spatial index/object iterator callback function type."]
pub type cpSpatialIndexIteratorFunc =
    ::core::option::Option<unsafe extern "C" fn(obj: *mut libc::c_void, data: *mut libc::c_void)>;
#[doc = " Spatial query callback function type."]
pub type cpSpatialIndexQueryFunc = ::core::option::Option<
    unsafe extern "C" fn(
        obj1: *mut libc::c_void,
        obj2: *mut libc::c_void,
        id: cpCollisionID,
        data: *mut libc::c_void,
    ) -> cpCollisionID,
>;
#[doc = " Spatial segment query callback function type."]
pub type cpSpatialIndexSegmentQueryFunc = ::core::option::Option<
    unsafe extern "C" fn(
        obj1: *mut libc::c_void,
        obj2: *mut libc::c_void,
        data: *mut libc::c_void,
    ) -> cpFloat,
>;
#[doc = " @private"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cpSpatialIndex {
    pub klass: *mut cpSpatialIndexClass,
    pub bbfunc: cpSpatialIndexBBFunc,
    pub staticIndex: *mut cpSpatialIndex,
    pub dynamicIndex: *mut cpSpatialIndex,
}
#[test]
fn bindgen_test_layout_cpSpatialIndex() {
    assert_eq!(
        ::core::mem::size_of::<cpSpatialIndex>(),
        32usize,
        concat!("Size of: ", stringify!(cpSpatialIndex))
    );
    assert_eq!(
        ::core::mem::align_of::<cpSpatialIndex>(),
        8usize,
        concat!("Alignment of ", stringify!(cpSpatialIndex))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cpSpatialIndex>())).klass as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cpSpatialIndex),
            "::",
            stringify!(klass)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cpSpatialIndex>())).bbfunc as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cpSpatialIndex),
            "::",
            stringify!(bbfunc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cpSpatialIndex>())).staticIndex as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cpSpatialIndex),
            "::",
            stringify!(staticIndex)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cpSpatialIndex>())).dynamicIndex as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cpSpatialIndex),
            "::",
            stringify!(dynamicIndex)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cpSpaceHash {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Allocate a spatial hash."]
    pub fn cpSpaceHashAlloc() -> *mut cpSpaceHash;
}
extern "C" {
    #[doc = " Initialize a spatial hash."]
    pub fn cpSpaceHashInit(
        hash: *mut cpSpaceHash,
        celldim: cpFloat,
        numcells: libc::c_int,
        bbfunc: cpSpatialIndexBBFunc,
        staticIndex: *mut cpSpatialIndex,
    ) -> *mut cpSpatialIndex;
}
extern "C" {
    #[doc = " Allocate and initialize a spatial hash."]
    pub fn cpSpaceHashNew(
        celldim: cpFloat,
        cells: libc::c_int,
        bbfunc: cpSpatialIndexBBFunc,
        staticIndex: *mut cpSpatialIndex,
    ) -> *mut cpSpatialIndex;
}
extern "C" {
    #[doc = " Change the cell dimensions and table size of the spatial hash to tune it."]
    #[doc = " The cell dimensions should roughly match the average size of your objects"]
    #[doc = " and the table size should be ~10 larger than the number of objects inserted."]
    #[doc = " Some trial and error is required to find the optimum numbers for efficiency."]
    pub fn cpSpaceHashResize(hash: *mut cpSpaceHash, celldim: cpFloat, numcells: libc::c_int);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cpBBTree {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Allocate a bounding box tree."]
    pub fn cpBBTreeAlloc() -> *mut cpBBTree;
}
extern "C" {
    #[doc = " Initialize a bounding box tree."]
    pub fn cpBBTreeInit(
        tree: *mut cpBBTree,
        bbfunc: cpSpatialIndexBBFunc,
        staticIndex: *mut cpSpatialIndex,
    ) -> *mut cpSpatialIndex;
}
extern "C" {
    #[doc = " Allocate and initialize a bounding box tree."]
    pub fn cpBBTreeNew(
        bbfunc: cpSpatialIndexBBFunc,
        staticIndex: *mut cpSpatialIndex,
    ) -> *mut cpSpatialIndex;
}
extern "C" {
    #[doc = " Perform a static top down optimization of the tree."]
    pub fn cpBBTreeOptimize(index: *mut cpSpatialIndex);
}
#[doc = " Bounding box tree velocity callback function."]
#[doc = " This function should return an estimate for the object's velocity."]
pub type cpBBTreeVelocityFunc =
    ::core::option::Option<unsafe extern "C" fn(obj: *mut libc::c_void) -> cpVect>;
extern "C" {
    #[doc = " Set the velocity function for the bounding box tree to enable temporal coherence."]
    pub fn cpBBTreeSetVelocityFunc(index: *mut cpSpatialIndex, func: cpBBTreeVelocityFunc);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cpSweep1D {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Allocate a 1D sort and sweep broadphase."]
    pub fn cpSweep1DAlloc() -> *mut cpSweep1D;
}
extern "C" {
    #[doc = " Initialize a 1D sort and sweep broadphase."]
    pub fn cpSweep1DInit(
        sweep: *mut cpSweep1D,
        bbfunc: cpSpatialIndexBBFunc,
        staticIndex: *mut cpSpatialIndex,
    ) -> *mut cpSpatialIndex;
}
extern "C" {
    #[doc = " Allocate and initialize a 1D sort and sweep broadphase."]
    pub fn cpSweep1DNew(
        bbfunc: cpSpatialIndexBBFunc,
        staticIndex: *mut cpSpatialIndex,
    ) -> *mut cpSpatialIndex;
}
pub type cpSpatialIndexDestroyImpl =
    ::core::option::Option<unsafe extern "C" fn(index: *mut cpSpatialIndex)>;
pub type cpSpatialIndexCountImpl =
    ::core::option::Option<unsafe extern "C" fn(index: *mut cpSpatialIndex) -> libc::c_int>;
pub type cpSpatialIndexEachImpl = ::core::option::Option<
    unsafe extern "C" fn(
        index: *mut cpSpatialIndex,
        func: cpSpatialIndexIteratorFunc,
        data: *mut libc::c_void,
    ),
>;
pub type cpSpatialIndexContainsImpl = ::core::option::Option<
    unsafe extern "C" fn(
        index: *mut cpSpatialIndex,
        obj: *mut libc::c_void,
        hashid: cpHashValue,
    ) -> cpBool,
>;
pub type cpSpatialIndexInsertImpl = ::core::option::Option<
    unsafe extern "C" fn(index: *mut cpSpatialIndex, obj: *mut libc::c_void, hashid: cpHashValue),
>;
pub type cpSpatialIndexRemoveImpl = ::core::option::Option<
    unsafe extern "C" fn(index: *mut cpSpatialIndex, obj: *mut libc::c_void, hashid: cpHashValue),
>;
pub type cpSpatialIndexReindexImpl =
    ::core::option::Option<unsafe extern "C" fn(index: *mut cpSpatialIndex)>;
pub type cpSpatialIndexReindexObjectImpl = ::core::option::Option<
    unsafe extern "C" fn(index: *mut cpSpatialIndex, obj: *mut libc::c_void, hashid: cpHashValue),
>;
pub type cpSpatialIndexReindexQueryImpl = ::core::option::Option<
    unsafe extern "C" fn(
        index: *mut cpSpatialIndex,
        func: cpSpatialIndexQueryFunc,
        data: *mut libc::c_void,
    ),
>;
pub type cpSpatialIndexQueryImpl = ::core::option::Option<
    unsafe extern "C" fn(
        index: *mut cpSpatialIndex,
        obj: *mut libc::c_void,
        bb: cpBB,
        func: cpSpatialIndexQueryFunc,
        data: *mut libc::c_void,
    ),
>;
pub type cpSpatialIndexSegmentQueryImpl = ::core::option::Option<
    unsafe extern "C" fn(
        index: *mut cpSpatialIndex,
        obj: *mut libc::c_void,
        a: cpVect,
        b: cpVect,
        t_exit: cpFloat,
        func: cpSpatialIndexSegmentQueryFunc,
        data: *mut libc::c_void,
    ),
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cpSpatialIndexClass {
    pub destroy: cpSpatialIndexDestroyImpl,
    pub count: cpSpatialIndexCountImpl,
    pub each: cpSpatialIndexEachImpl,
    pub contains: cpSpatialIndexContainsImpl,
    pub insert: cpSpatialIndexInsertImpl,
    pub remove: cpSpatialIndexRemoveImpl,
    pub reindex: cpSpatialIndexReindexImpl,
    pub reindexObject: cpSpatialIndexReindexObjectImpl,
    pub reindexQuery: cpSpatialIndexReindexQueryImpl,
    pub query: cpSpatialIndexQueryImpl,
    pub segmentQuery: cpSpatialIndexSegmentQueryImpl,
}
#[test]
fn bindgen_test_layout_cpSpatialIndexClass() {
    assert_eq!(
        ::core::mem::size_of::<cpSpatialIndexClass>(),
        88usize,
        concat!("Size of: ", stringify!(cpSpatialIndexClass))
    );
    assert_eq!(
        ::core::mem::align_of::<cpSpatialIndexClass>(),
        8usize,
        concat!("Alignment of ", stringify!(cpSpatialIndexClass))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cpSpatialIndexClass>())).destroy as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cpSpatialIndexClass),
            "::",
            stringify!(destroy)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cpSpatialIndexClass>())).count as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cpSpatialIndexClass),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cpSpatialIndexClass>())).each as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cpSpatialIndexClass),
            "::",
            stringify!(each)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cpSpatialIndexClass>())).contains as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cpSpatialIndexClass),
            "::",
            stringify!(contains)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cpSpatialIndexClass>())).insert as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cpSpatialIndexClass),
            "::",
            stringify!(insert)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cpSpatialIndexClass>())).remove as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cpSpatialIndexClass),
            "::",
            stringify!(remove)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cpSpatialIndexClass>())).reindex as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(cpSpatialIndexClass),
            "::",
            stringify!(reindex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<cpSpatialIndexClass>())).reindexObject as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(cpSpatialIndexClass),
            "::",
            stringify!(reindexObject)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<cpSpatialIndexClass>())).reindexQuery as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(cpSpatialIndexClass),
            "::",
            stringify!(reindexQuery)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cpSpatialIndexClass>())).query as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(cpSpatialIndexClass),
            "::",
            stringify!(query)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<cpSpatialIndexClass>())).segmentQuery as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(cpSpatialIndexClass),
            "::",
            stringify!(segmentQuery)
        )
    );
}
extern "C" {
    #[doc = " Destroy and free a spatial index."]
    pub fn cpSpatialIndexFree(index: *mut cpSpatialIndex);
}
extern "C" {
    #[doc = " Collide the objects in @c dynamicIndex against the objects in @c staticIndex using the query callback function."]
    pub fn cpSpatialIndexCollideStatic(
        dynamicIndex: *mut cpSpatialIndex,
        staticIndex: *mut cpSpatialIndex,
        func: cpSpatialIndexQueryFunc,
        data: *mut libc::c_void,
    );
}
extern "C" {
    #[doc = " Get the restitution (elasticity) that will be applied to the pair of colliding objects."]
    pub fn cpArbiterGetRestitution(arb: *const cpArbiter) -> cpFloat;
}
extern "C" {
    #[doc = " Override the restitution (elasticity) that will be applied to the pair of colliding objects."]
    pub fn cpArbiterSetRestitution(arb: *mut cpArbiter, restitution: cpFloat);
}
extern "C" {
    #[doc = " Get the friction coefficient that will be applied to the pair of colliding objects."]
    pub fn cpArbiterGetFriction(arb: *const cpArbiter) -> cpFloat;
}
extern "C" {
    #[doc = " Override the friction coefficient that will be applied to the pair of colliding objects."]
    pub fn cpArbiterSetFriction(arb: *mut cpArbiter, friction: cpFloat);
}
extern "C" {
    pub fn cpArbiterGetSurfaceVelocity(arb: *mut cpArbiter) -> cpVect;
}
extern "C" {
    pub fn cpArbiterSetSurfaceVelocity(arb: *mut cpArbiter, vr: cpVect);
}
extern "C" {
    #[doc = " Get the user data pointer associated with this pair of colliding objects."]
    pub fn cpArbiterGetUserData(arb: *const cpArbiter) -> cpDataPointer;
}
extern "C" {
    #[doc = " Set a user data point associated with this pair of colliding objects."]
    #[doc = " If you need to perform any cleanup for this pointer, you must do it yourself, in the separate callback for instance."]
    pub fn cpArbiterSetUserData(arb: *mut cpArbiter, userData: cpDataPointer);
}
extern "C" {
    #[doc = " Calculate the total impulse including the friction that was applied by this arbiter."]
    #[doc = " This function should only be called from a post-solve, post-step or cpBodyEachArbiter callback."]
    pub fn cpArbiterTotalImpulse(arb: *const cpArbiter) -> cpVect;
}
extern "C" {
    #[doc = " Calculate the amount of energy lost in a collision including static, but not dynamic friction."]
    #[doc = " This function should only be called from a post-solve, post-step or cpBodyEachArbiter callback."]
    pub fn cpArbiterTotalKE(arb: *const cpArbiter) -> cpFloat;
}
extern "C" {
    #[doc = " Mark a collision pair to be ignored until the two objects separate."]
    #[doc = " Pre-solve and post-solve callbacks will not be called, but the separate callback will be called."]
    pub fn cpArbiterIgnore(arb: *mut cpArbiter) -> cpBool;
}
extern "C" {
    #[doc = " Return the colliding shapes involved for this arbiter."]
    #[doc = " The order of their cpSpace.collision_type values will match"]
    #[doc = " the order set when the collision handler was registered."]
    pub fn cpArbiterGetShapes(arb: *const cpArbiter, a: *mut *mut cpShape, b: *mut *mut cpShape);
}
extern "C" {
    #[doc = " Return the colliding bodies involved for this arbiter."]
    #[doc = " The order of the cpSpace.collision_type the bodies are associated with values will match"]
    #[doc = " the order set when the collision handler was registered."]
    pub fn cpArbiterGetBodies(arb: *const cpArbiter, a: *mut *mut cpBody, b: *mut *mut cpBody);
}
#[doc = " A struct that wraps up the important collision data for an arbiter."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cpContactPointSet {
    #[doc = " The number of contact points in the set."]
    pub count: libc::c_int,
    #[doc = " The normal of the collision."]
    pub normal: cpVect,
    pub points: [cpContactPointSet__bindgen_ty_1; 2usize],
}
#[doc = " The array of contact points."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cpContactPointSet__bindgen_ty_1 {
    #[doc = " The position of the contact on the surface of each shape."]
    pub pointA: cpVect,
    #[doc = " The position of the contact on the surface of each shape."]
    pub pointB: cpVect,
    #[doc = " Penetration distance of the two shapes. Overlapping means it will be negative."]
    #[doc = " This value is calculated as cpvdot(cpvsub(point2, point1), normal) and is ignored by cpArbiterSetContactPointSet()."]
    pub distance: cpFloat,
}
#[test]
fn bindgen_test_layout_cpContactPointSet__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<cpContactPointSet__bindgen_ty_1>(),
        40usize,
        concat!("Size of: ", stringify!(cpContactPointSet__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<cpContactPointSet__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(cpContactPointSet__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<cpContactPointSet__bindgen_ty_1>())).pointA as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cpContactPointSet__bindgen_ty_1),
            "::",
            stringify!(pointA)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<cpContactPointSet__bindgen_ty_1>())).pointB as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cpContactPointSet__bindgen_ty_1),
            "::",
            stringify!(pointB)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<cpContactPointSet__bindgen_ty_1>())).distance as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cpContactPointSet__bindgen_ty_1),
            "::",
            stringify!(distance)
        )
    );
}
#[test]
fn bindgen_test_layout_cpContactPointSet() {
    assert_eq!(
        ::core::mem::size_of::<cpContactPointSet>(),
        104usize,
        concat!("Size of: ", stringify!(cpContactPointSet))
    );
    assert_eq!(
        ::core::mem::align_of::<cpContactPointSet>(),
        8usize,
        concat!("Alignment of ", stringify!(cpContactPointSet))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cpContactPointSet>())).count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cpContactPointSet),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cpContactPointSet>())).normal as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cpContactPointSet),
            "::",
            stringify!(normal)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cpContactPointSet>())).points as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cpContactPointSet),
            "::",
            stringify!(points)
        )
    );
}
extern "C" {
    #[doc = " Return a contact set from an arbiter."]
    pub fn cpArbiterGetContactPointSet(arb: *const cpArbiter) -> cpContactPointSet;
}
extern "C" {
    #[doc = " Replace the contact point set for an arbiter."]
    #[doc = " This can be a very powerful feature, but use it with caution!"]
    pub fn cpArbiterSetContactPointSet(arb: *mut cpArbiter, set: *mut cpContactPointSet);
}
extern "C" {
    #[doc = " Returns true if this is the first step a pair of objects started colliding."]
    pub fn cpArbiterIsFirstContact(arb: *const cpArbiter) -> cpBool;
}
extern "C" {
    #[doc = " Returns true if the separate callback is due to a shape being removed from the space."]
    pub fn cpArbiterIsRemoval(arb: *const cpArbiter) -> cpBool;
}
extern "C" {
    #[doc = " Get the number of contact points for this arbiter."]
    pub fn cpArbiterGetCount(arb: *const cpArbiter) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the normal of the collision."]
    pub fn cpArbiterGetNormal(arb: *const cpArbiter) -> cpVect;
}
extern "C" {
    #[doc = " Get the position of the @c ith contact point on the surface of the first shape."]
    pub fn cpArbiterGetPointA(arb: *const cpArbiter, i: libc::c_int) -> cpVect;
}
extern "C" {
    #[doc = " Get the position of the @c ith contact point on the surface of the second shape."]
    pub fn cpArbiterGetPointB(arb: *const cpArbiter, i: libc::c_int) -> cpVect;
}
extern "C" {
    #[doc = " Get the depth of the @c ith contact point."]
    pub fn cpArbiterGetDepth(arb: *const cpArbiter, i: libc::c_int) -> cpFloat;
}
extern "C" {
    #[doc = " If you want a custom callback to invoke the wildcard callback for the first collision type, you must call this function explicitly."]
    #[doc = " You must decide how to handle the wildcard's return value since it may disagree with the other wildcard handler's return value or your own."]
    pub fn cpArbiterCallWildcardBeginA(arb: *mut cpArbiter, space: *mut cpSpace) -> cpBool;
}
extern "C" {
    #[doc = " If you want a custom callback to invoke the wildcard callback for the second collision type, you must call this function explicitly."]
    #[doc = " You must decide how to handle the wildcard's return value since it may disagree with the other wildcard handler's return value or your own."]
    pub fn cpArbiterCallWildcardBeginB(arb: *mut cpArbiter, space: *mut cpSpace) -> cpBool;
}
extern "C" {
    #[doc = " If you want a custom callback to invoke the wildcard callback for the first collision type, you must call this function explicitly."]
    #[doc = " You must decide how to handle the wildcard's return value since it may disagree with the other wildcard handler's return value or your own."]
    pub fn cpArbiterCallWildcardPreSolveA(arb: *mut cpArbiter, space: *mut cpSpace) -> cpBool;
}
extern "C" {
    #[doc = " If you want a custom callback to invoke the wildcard callback for the second collision type, you must call this function explicitly."]
    #[doc = " You must decide how to handle the wildcard's return value since it may disagree with the other wildcard handler's return value or your own."]
    pub fn cpArbiterCallWildcardPreSolveB(arb: *mut cpArbiter, space: *mut cpSpace) -> cpBool;
}
extern "C" {
    #[doc = " If you want a custom callback to invoke the wildcard callback for the first collision type, you must call this function explicitly."]
    pub fn cpArbiterCallWildcardPostSolveA(arb: *mut cpArbiter, space: *mut cpSpace);
}
extern "C" {
    #[doc = " If you want a custom callback to invoke the wildcard callback for the second collision type, you must call this function explicitly."]
    pub fn cpArbiterCallWildcardPostSolveB(arb: *mut cpArbiter, space: *mut cpSpace);
}
extern "C" {
    #[doc = " If you want a custom callback to invoke the wildcard callback for the first collision type, you must call this function explicitly."]
    pub fn cpArbiterCallWildcardSeparateA(arb: *mut cpArbiter, space: *mut cpSpace);
}
extern "C" {
    #[doc = " If you want a custom callback to invoke the wildcard callback for the second collision type, you must call this function explicitly."]
    pub fn cpArbiterCallWildcardSeparateB(arb: *mut cpArbiter, space: *mut cpSpace);
}
#[repr(u32)]
#[doc = " @defgroup cpBody cpBody"]
#[doc = " Chipmunk's rigid body type. Rigid bodies hold the physical properties of an object like"]
#[doc = " it's mass, and position and velocity of it's center of gravity. They don't have an shape on their own."]
#[doc = " They are given a shape by creating collision shapes (cpShape) that point to the body."]
#[doc = " @{"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum cpBodyType {
    #[doc = " A dynamic body is one that is affected by gravity, forces, and collisions."]
    #[doc = " This is the default body type."]
    CP_BODY_TYPE_DYNAMIC = 0,
    #[doc = " A kinematic body is an infinite mass, user controlled body that is not affected by gravity, forces or collisions."]
    #[doc = " Instead the body only moves based on it's velocity."]
    #[doc = " Dynamic bodies collide normally with kinematic bodies, though the kinematic body will be unaffected."]
    #[doc = " Collisions between two kinematic bodies, or a kinematic body and a static body produce collision callbacks, but no collision response."]
    CP_BODY_TYPE_KINEMATIC = 1,
    #[doc = " A static body is a body that never (or rarely) moves. If you move a static body, you must call one of the cpSpaceReindex*() functions."]
    #[doc = " Chipmunk uses this information to optimize the collision detection."]
    #[doc = " Static bodies do not produce collision callbacks when colliding with other static bodies."]
    CP_BODY_TYPE_STATIC = 2,
}
#[doc = " Rigid body velocity update function type."]
pub type cpBodyVelocityFunc = ::core::option::Option<
    unsafe extern "C" fn(body: *mut cpBody, gravity: cpVect, damping: cpFloat, dt: cpFloat),
>;
#[doc = " Rigid body position update function type."]
pub type cpBodyPositionFunc =
    ::core::option::Option<unsafe extern "C" fn(body: *mut cpBody, dt: cpFloat)>;
extern "C" {
    #[doc = " Allocate a cpBody."]
    pub fn cpBodyAlloc() -> *mut cpBody;
}
extern "C" {
    #[doc = " Initialize a cpBody."]
    pub fn cpBodyInit(body: *mut cpBody, mass: cpFloat, moment: cpFloat) -> *mut cpBody;
}
extern "C" {
    #[doc = " Allocate and initialize a cpBody."]
    pub fn cpBodyNew(mass: cpFloat, moment: cpFloat) -> *mut cpBody;
}
extern "C" {
    #[doc = " Allocate and initialize a cpBody, and set it as a kinematic body."]
    pub fn cpBodyNewKinematic() -> *mut cpBody;
}
extern "C" {
    #[doc = " Allocate and initialize a cpBody, and set it as a static body."]
    pub fn cpBodyNewStatic() -> *mut cpBody;
}
extern "C" {
    #[doc = " Destroy a cpBody."]
    pub fn cpBodyDestroy(body: *mut cpBody);
}
extern "C" {
    #[doc = " Destroy and free a cpBody."]
    pub fn cpBodyFree(body: *mut cpBody);
}
extern "C" {
    #[doc = " Wake up a sleeping or idle body."]
    pub fn cpBodyActivate(body: *mut cpBody);
}
extern "C" {
    #[doc = " Wake up any sleeping or idle bodies touching a static body."]
    pub fn cpBodyActivateStatic(body: *mut cpBody, filter: *mut cpShape);
}
extern "C" {
    #[doc = " Force a body to fall asleep immediately."]
    pub fn cpBodySleep(body: *mut cpBody);
}
extern "C" {
    #[doc = " Force a body to fall asleep immediately along with other bodies in a group."]
    pub fn cpBodySleepWithGroup(body: *mut cpBody, group: *mut cpBody);
}
extern "C" {
    #[doc = " Returns true if the body is sleeping."]
    pub fn cpBodyIsSleeping(body: *const cpBody) -> cpBool;
}
extern "C" {
    #[doc = " Get the type of the body."]
    pub fn cpBodyGetType(body: *mut cpBody) -> cpBodyType;
}
extern "C" {
    #[doc = " Set the type of the body."]
    pub fn cpBodySetType(body: *mut cpBody, type_: cpBodyType);
}
extern "C" {
    #[doc = " Get the space this body is added to."]
    pub fn cpBodyGetSpace(body: *const cpBody) -> *mut cpSpace;
}
extern "C" {
    #[doc = " Get the mass of the body."]
    pub fn cpBodyGetMass(body: *const cpBody) -> cpFloat;
}
extern "C" {
    #[doc = " Set the mass of the body."]
    pub fn cpBodySetMass(body: *mut cpBody, m: cpFloat);
}
extern "C" {
    #[doc = " Get the moment of inertia of the body."]
    pub fn cpBodyGetMoment(body: *const cpBody) -> cpFloat;
}
extern "C" {
    #[doc = " Set the moment of inertia of the body."]
    pub fn cpBodySetMoment(body: *mut cpBody, i: cpFloat);
}
extern "C" {
    #[doc = " Set the position of a body."]
    pub fn cpBodyGetPosition(body: *const cpBody) -> cpVect;
}
extern "C" {
    #[doc = " Set the position of the body."]
    pub fn cpBodySetPosition(body: *mut cpBody, pos: cpVect);
}
extern "C" {
    #[doc = " Get the offset of the center of gravity in body local coordinates."]
    pub fn cpBodyGetCenterOfGravity(body: *const cpBody) -> cpVect;
}
extern "C" {
    #[doc = " Set the offset of the center of gravity in body local coordinates."]
    pub fn cpBodySetCenterOfGravity(body: *mut cpBody, cog: cpVect);
}
extern "C" {
    #[doc = " Get the velocity of the body."]
    pub fn cpBodyGetVelocity(body: *const cpBody) -> cpVect;
}
extern "C" {
    #[doc = " Set the velocity of the body."]
    pub fn cpBodySetVelocity(body: *mut cpBody, velocity: cpVect);
}
extern "C" {
    #[doc = " Get the force applied to the body for the next time step."]
    pub fn cpBodyGetForce(body: *const cpBody) -> cpVect;
}
extern "C" {
    #[doc = " Set the force applied to the body for the next time step."]
    pub fn cpBodySetForce(body: *mut cpBody, force: cpVect);
}
extern "C" {
    #[doc = " Get the angle of the body."]
    pub fn cpBodyGetAngle(body: *const cpBody) -> cpFloat;
}
extern "C" {
    #[doc = " Set the angle of a body."]
    pub fn cpBodySetAngle(body: *mut cpBody, a: cpFloat);
}
extern "C" {
    #[doc = " Get the angular velocity of the body."]
    pub fn cpBodyGetAngularVelocity(body: *const cpBody) -> cpFloat;
}
extern "C" {
    #[doc = " Set the angular velocity of the body."]
    pub fn cpBodySetAngularVelocity(body: *mut cpBody, angularVelocity: cpFloat);
}
extern "C" {
    #[doc = " Get the torque applied to the body for the next time step."]
    pub fn cpBodyGetTorque(body: *const cpBody) -> cpFloat;
}
extern "C" {
    #[doc = " Set the torque applied to the body for the next time step."]
    pub fn cpBodySetTorque(body: *mut cpBody, torque: cpFloat);
}
extern "C" {
    #[doc = " Get the rotation vector of the body. (The x basis vector of it's transform.)"]
    pub fn cpBodyGetRotation(body: *const cpBody) -> cpVect;
}
extern "C" {
    #[doc = " Get the user data pointer assigned to the body."]
    pub fn cpBodyGetUserData(body: *const cpBody) -> cpDataPointer;
}
extern "C" {
    #[doc = " Set the user data pointer assigned to the body."]
    pub fn cpBodySetUserData(body: *mut cpBody, userData: cpDataPointer);
}
extern "C" {
    #[doc = " Set the callback used to update a body's velocity."]
    pub fn cpBodySetVelocityUpdateFunc(body: *mut cpBody, velocityFunc: cpBodyVelocityFunc);
}
extern "C" {
    #[doc = " Set the callback used to update a body's position."]
    #[doc = " NOTE: It's not generally recommended to override this unless you call the default position update function."]
    pub fn cpBodySetPositionUpdateFunc(body: *mut cpBody, positionFunc: cpBodyPositionFunc);
}
extern "C" {
    #[doc = " Default velocity integration function.."]
    pub fn cpBodyUpdateVelocity(body: *mut cpBody, gravity: cpVect, damping: cpFloat, dt: cpFloat);
}
extern "C" {
    #[doc = " Default position integration function."]
    pub fn cpBodyUpdatePosition(body: *mut cpBody, dt: cpFloat);
}
extern "C" {
    #[doc = " Convert body relative/local coordinates to absolute/world coordinates."]
    pub fn cpBodyLocalToWorld(body: *const cpBody, point: cpVect) -> cpVect;
}
extern "C" {
    #[doc = " Convert body absolute/world coordinates to  relative/local coordinates."]
    pub fn cpBodyWorldToLocal(body: *const cpBody, point: cpVect) -> cpVect;
}
extern "C" {
    #[doc = " Apply a force to a body. Both the force and point are expressed in world coordinates."]
    pub fn cpBodyApplyForceAtWorldPoint(body: *mut cpBody, force: cpVect, point: cpVect);
}
extern "C" {
    #[doc = " Apply a force to a body. Both the force and point are expressed in body local coordinates."]
    pub fn cpBodyApplyForceAtLocalPoint(body: *mut cpBody, force: cpVect, point: cpVect);
}
extern "C" {
    #[doc = " Apply an impulse to a body. Both the impulse and point are expressed in world coordinates."]
    pub fn cpBodyApplyImpulseAtWorldPoint(body: *mut cpBody, impulse: cpVect, point: cpVect);
}
extern "C" {
    #[doc = " Apply an impulse to a body. Both the impulse and point are expressed in body local coordinates."]
    pub fn cpBodyApplyImpulseAtLocalPoint(body: *mut cpBody, impulse: cpVect, point: cpVect);
}
extern "C" {
    #[doc = " Get the velocity on a body (in world units) at a point on the body in world coordinates."]
    pub fn cpBodyGetVelocityAtWorldPoint(body: *const cpBody, point: cpVect) -> cpVect;
}
extern "C" {
    #[doc = " Get the velocity on a body (in world units) at a point on the body in local coordinates."]
    pub fn cpBodyGetVelocityAtLocalPoint(body: *const cpBody, point: cpVect) -> cpVect;
}
extern "C" {
    #[doc = " Get the amount of kinetic energy contained by the body."]
    pub fn cpBodyKineticEnergy(body: *const cpBody) -> cpFloat;
}
#[doc = " Body/shape iterator callback function type."]
pub type cpBodyShapeIteratorFunc = ::core::option::Option<
    unsafe extern "C" fn(body: *mut cpBody, shape: *mut cpShape, data: *mut libc::c_void),
>;
extern "C" {
    #[doc = " Call @c func once for each shape attached to @c body and added to the space."]
    pub fn cpBodyEachShape(
        body: *mut cpBody,
        func: cpBodyShapeIteratorFunc,
        data: *mut libc::c_void,
    );
}
#[doc = " Body/constraint iterator callback function type."]
pub type cpBodyConstraintIteratorFunc = ::core::option::Option<
    unsafe extern "C" fn(body: *mut cpBody, constraint: *mut cpConstraint, data: *mut libc::c_void),
>;
extern "C" {
    #[doc = " Call @c func once for each constraint attached to @c body and added to the space."]
    pub fn cpBodyEachConstraint(
        body: *mut cpBody,
        func: cpBodyConstraintIteratorFunc,
        data: *mut libc::c_void,
    );
}
#[doc = " Body/arbiter iterator callback function type."]
pub type cpBodyArbiterIteratorFunc = ::core::option::Option<
    unsafe extern "C" fn(body: *mut cpBody, arbiter: *mut cpArbiter, data: *mut libc::c_void),
>;
extern "C" {
    #[doc = " Call @c func once for each arbiter that is currently active on the body."]
    pub fn cpBodyEachArbiter(
        body: *mut cpBody,
        func: cpBodyArbiterIteratorFunc,
        data: *mut libc::c_void,
    );
}
#[doc = " Point query info struct."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cpPointQueryInfo {
    #[doc = " The nearest shape, NULL if no shape was within range."]
    pub shape: *const cpShape,
    #[doc = " The closest point on the shape's surface. (in world space coordinates)"]
    pub point: cpVect,
    #[doc = " The distance to the point. The distance is negative if the point is inside the shape."]
    pub distance: cpFloat,
    #[doc = " The gradient of the signed distance function."]
    #[doc = " The value should be similar to info.p/info.d, but accurate even for very small values of info.d."]
    pub gradient: cpVect,
}
#[test]
fn bindgen_test_layout_cpPointQueryInfo() {
    assert_eq!(
        ::core::mem::size_of::<cpPointQueryInfo>(),
        48usize,
        concat!("Size of: ", stringify!(cpPointQueryInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<cpPointQueryInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(cpPointQueryInfo))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cpPointQueryInfo>())).shape as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cpPointQueryInfo),
            "::",
            stringify!(shape)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cpPointQueryInfo>())).point as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cpPointQueryInfo),
            "::",
            stringify!(point)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cpPointQueryInfo>())).distance as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cpPointQueryInfo),
            "::",
            stringify!(distance)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cpPointQueryInfo>())).gradient as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cpPointQueryInfo),
            "::",
            stringify!(gradient)
        )
    );
}
#[doc = " Segment query info struct."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cpSegmentQueryInfo {
    #[doc = " The shape that was hit, or NULL if no collision occured."]
    pub shape: *const cpShape,
    #[doc = " The point of impact."]
    pub point: cpVect,
    #[doc = " The normal of the surface hit."]
    pub normal: cpVect,
    #[doc = " The normalized distance along the query segment in the range [0, 1]."]
    pub alpha: cpFloat,
}
#[test]
fn bindgen_test_layout_cpSegmentQueryInfo() {
    assert_eq!(
        ::core::mem::size_of::<cpSegmentQueryInfo>(),
        48usize,
        concat!("Size of: ", stringify!(cpSegmentQueryInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<cpSegmentQueryInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(cpSegmentQueryInfo))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cpSegmentQueryInfo>())).shape as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cpSegmentQueryInfo),
            "::",
            stringify!(shape)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cpSegmentQueryInfo>())).point as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cpSegmentQueryInfo),
            "::",
            stringify!(point)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cpSegmentQueryInfo>())).normal as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cpSegmentQueryInfo),
            "::",
            stringify!(normal)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cpSegmentQueryInfo>())).alpha as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cpSegmentQueryInfo),
            "::",
            stringify!(alpha)
        )
    );
}
#[doc = " Fast collision filtering type that is used to determine if two objects collide before calling collision or query callbacks."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cpShapeFilter {
    #[doc = " Two objects with the same non-zero group value do not collide."]
    #[doc = " This is generally used to group objects in a composite object together to disable self collisions."]
    pub group: cpGroup,
    #[doc = " A bitmask of user definable categories that this object belongs to."]
    #[doc = " The category/mask combinations of both objects in a collision must agree for a collision to occur."]
    pub categories: cpBitmask,
    #[doc = " A bitmask of user definable category types that this object object collides with."]
    #[doc = " The category/mask combinations of both objects in a collision must agree for a collision to occur."]
    pub mask: cpBitmask,
}
#[test]
fn bindgen_test_layout_cpShapeFilter() {
    assert_eq!(
        ::core::mem::size_of::<cpShapeFilter>(),
        16usize,
        concat!("Size of: ", stringify!(cpShapeFilter))
    );
    assert_eq!(
        ::core::mem::align_of::<cpShapeFilter>(),
        8usize,
        concat!("Alignment of ", stringify!(cpShapeFilter))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cpShapeFilter>())).group as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cpShapeFilter),
            "::",
            stringify!(group)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cpShapeFilter>())).categories as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cpShapeFilter),
            "::",
            stringify!(categories)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cpShapeFilter>())).mask as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cpShapeFilter),
            "::",
            stringify!(mask)
        )
    );
}
extern "C" {
    pub static CP_SHAPE_FILTER_ALL: cpShapeFilter;
}
extern "C" {
    pub static CP_SHAPE_FILTER_NONE: cpShapeFilter;
}
extern "C" {
    #[doc = " Destroy a shape."]
    pub fn cpShapeDestroy(shape: *mut cpShape);
}
extern "C" {
    #[doc = " Destroy and Free a shape."]
    pub fn cpShapeFree(shape: *mut cpShape);
}
extern "C" {
    #[doc = " Update, cache and return the bounding box of a shape based on the body it's attached to."]
    pub fn cpShapeCacheBB(shape: *mut cpShape) -> cpBB;
}
extern "C" {
    #[doc = " Update, cache and return the bounding box of a shape with an explicit transformation."]
    pub fn cpShapeUpdate(shape: *mut cpShape, transform: cpTransform) -> cpBB;
}
extern "C" {
    #[doc = " Perform a nearest point query. It finds the closest point on the surface of shape to a specific point."]
    #[doc = " The value returned is the distance between the points. A negative distance means the point is inside the shape."]
    pub fn cpShapePointQuery(
        shape: *const cpShape,
        p: cpVect,
        out: *mut cpPointQueryInfo,
    ) -> cpFloat;
}
extern "C" {
    #[doc = " Perform a segment query against a shape. @c info must be a pointer to a valid cpSegmentQueryInfo structure."]
    pub fn cpShapeSegmentQuery(
        shape: *const cpShape,
        a: cpVect,
        b: cpVect,
        radius: cpFloat,
        info: *mut cpSegmentQueryInfo,
    ) -> cpBool;
}
extern "C" {
    #[doc = " Return contact information about two shapes."]
    pub fn cpShapesCollide(a: *const cpShape, b: *const cpShape) -> cpContactPointSet;
}
extern "C" {
    #[doc = " The cpSpace this body is added to."]
    pub fn cpShapeGetSpace(shape: *const cpShape) -> *mut cpSpace;
}
extern "C" {
    #[doc = " The cpBody this shape is connected to."]
    pub fn cpShapeGetBody(shape: *const cpShape) -> *mut cpBody;
}
extern "C" {
    #[doc = " Set the cpBody this shape is connected to."]
    #[doc = " Can only be used if the shape is not currently added to a space."]
    pub fn cpShapeSetBody(shape: *mut cpShape, body: *mut cpBody);
}
extern "C" {
    #[doc = " Get the mass of the shape if you are having Chipmunk calculate mass properties for you."]
    pub fn cpShapeGetMass(shape: *mut cpShape) -> cpFloat;
}
extern "C" {
    #[doc = " Set the mass of this shape to have Chipmunk calculate mass properties for you."]
    pub fn cpShapeSetMass(shape: *mut cpShape, mass: cpFloat);
}
extern "C" {
    #[doc = " Get the density of the shape if you are having Chipmunk calculate mass properties for you."]
    pub fn cpShapeGetDensity(shape: *mut cpShape) -> cpFloat;
}
extern "C" {
    #[doc = " Set the density  of this shape to have Chipmunk calculate mass properties for you."]
    pub fn cpShapeSetDensity(shape: *mut cpShape, density: cpFloat);
}
extern "C" {
    #[doc = " Get the calculated moment of inertia for this shape."]
    pub fn cpShapeGetMoment(shape: *mut cpShape) -> cpFloat;
}
extern "C" {
    #[doc = " Get the calculated area of this shape."]
    pub fn cpShapeGetArea(shape: *mut cpShape) -> cpFloat;
}
extern "C" {
    #[doc = " Get the centroid of this shape."]
    pub fn cpShapeGetCenterOfGravity(shape: *mut cpShape) -> cpVect;
}
extern "C" {
    #[doc = " Get the bounding box that contains the shape given it's current position and angle."]
    pub fn cpShapeGetBB(shape: *const cpShape) -> cpBB;
}
extern "C" {
    #[doc = " Get if the shape is set to be a sensor or not."]
    pub fn cpShapeGetSensor(shape: *const cpShape) -> cpBool;
}
extern "C" {
    #[doc = " Set if the shape is a sensor or not."]
    pub fn cpShapeSetSensor(shape: *mut cpShape, sensor: cpBool);
}
extern "C" {
    #[doc = " Get the elasticity of this shape."]
    pub fn cpShapeGetElasticity(shape: *const cpShape) -> cpFloat;
}
extern "C" {
    #[doc = " Set the elasticity of this shape."]
    pub fn cpShapeSetElasticity(shape: *mut cpShape, elasticity: cpFloat);
}
extern "C" {
    #[doc = " Get the friction of this shape."]
    pub fn cpShapeGetFriction(shape: *const cpShape) -> cpFloat;
}
extern "C" {
    #[doc = " Set the friction of this shape."]
    pub fn cpShapeSetFriction(shape: *mut cpShape, friction: cpFloat);
}
extern "C" {
    #[doc = " Get the surface velocity of this shape."]
    pub fn cpShapeGetSurfaceVelocity(shape: *const cpShape) -> cpVect;
}
extern "C" {
    #[doc = " Set the surface velocity of this shape."]
    pub fn cpShapeSetSurfaceVelocity(shape: *mut cpShape, surfaceVelocity: cpVect);
}
extern "C" {
    #[doc = " Get the user definable data pointer of this shape."]
    pub fn cpShapeGetUserData(shape: *const cpShape) -> cpDataPointer;
}
extern "C" {
    #[doc = " Set the user definable data pointer of this shape."]
    pub fn cpShapeSetUserData(shape: *mut cpShape, userData: cpDataPointer);
}
extern "C" {
    #[doc = " Set the collision type of this shape."]
    pub fn cpShapeGetCollisionType(shape: *const cpShape) -> cpCollisionType;
}
extern "C" {
    #[doc = " Get the collision type of this shape."]
    pub fn cpShapeSetCollisionType(shape: *mut cpShape, collisionType: cpCollisionType);
}
extern "C" {
    #[doc = " Get the collision filtering parameters of this shape."]
    pub fn cpShapeGetFilter(shape: *const cpShape) -> cpShapeFilter;
}
extern "C" {
    #[doc = " Set the collision filtering parameters of this shape."]
    pub fn cpShapeSetFilter(shape: *mut cpShape, filter: cpShapeFilter);
}
extern "C" {
    #[doc = " Allocate a circle shape."]
    pub fn cpCircleShapeAlloc() -> *mut cpCircleShape;
}
extern "C" {
    #[doc = " Initialize a circle shape."]
    pub fn cpCircleShapeInit(
        circle: *mut cpCircleShape,
        body: *mut cpBody,
        radius: cpFloat,
        offset: cpVect,
    ) -> *mut cpCircleShape;
}
extern "C" {
    #[doc = " Allocate and initialize a circle shape."]
    pub fn cpCircleShapeNew(body: *mut cpBody, radius: cpFloat, offset: cpVect) -> *mut cpShape;
}
extern "C" {
    #[doc = " Get the offset of a circle shape."]
    pub fn cpCircleShapeGetOffset(shape: *const cpShape) -> cpVect;
}
extern "C" {
    #[doc = " Get the radius of a circle shape."]
    pub fn cpCircleShapeGetRadius(shape: *const cpShape) -> cpFloat;
}
extern "C" {
    #[doc = " Allocate a segment shape."]
    pub fn cpSegmentShapeAlloc() -> *mut cpSegmentShape;
}
extern "C" {
    #[doc = " Initialize a segment shape."]
    pub fn cpSegmentShapeInit(
        seg: *mut cpSegmentShape,
        body: *mut cpBody,
        a: cpVect,
        b: cpVect,
        radius: cpFloat,
    ) -> *mut cpSegmentShape;
}
extern "C" {
    #[doc = " Allocate and initialize a segment shape."]
    pub fn cpSegmentShapeNew(
        body: *mut cpBody,
        a: cpVect,
        b: cpVect,
        radius: cpFloat,
    ) -> *mut cpShape;
}
extern "C" {
    #[doc = " Let Chipmunk know about the geometry of adjacent segments to avoid colliding with endcaps."]
    pub fn cpSegmentShapeSetNeighbors(shape: *mut cpShape, prev: cpVect, next: cpVect);
}
extern "C" {
    #[doc = " Get the first endpoint of a segment shape."]
    pub fn cpSegmentShapeGetA(shape: *const cpShape) -> cpVect;
}
extern "C" {
    #[doc = " Get the second endpoint of a segment shape."]
    pub fn cpSegmentShapeGetB(shape: *const cpShape) -> cpVect;
}
extern "C" {
    #[doc = " Get the normal of a segment shape."]
    pub fn cpSegmentShapeGetNormal(shape: *const cpShape) -> cpVect;
}
extern "C" {
    #[doc = " Get the first endpoint of a segment shape."]
    pub fn cpSegmentShapeGetRadius(shape: *const cpShape) -> cpFloat;
}
extern "C" {
    #[doc = " Allocate a polygon shape."]
    pub fn cpPolyShapeAlloc() -> *mut cpPolyShape;
}
extern "C" {
    #[doc = " Initialize a polygon shape with rounded corners."]
    #[doc = " A convex hull will be created from the vertexes."]
    pub fn cpPolyShapeInit(
        poly: *mut cpPolyShape,
        body: *mut cpBody,
        count: libc::c_int,
        verts: *const cpVect,
        transform: cpTransform,
        radius: cpFloat,
    ) -> *mut cpPolyShape;
}
extern "C" {
    #[doc = " Initialize a polygon shape with rounded corners."]
    #[doc = " The vertexes must be convex with a counter-clockwise winding."]
    pub fn cpPolyShapeInitRaw(
        poly: *mut cpPolyShape,
        body: *mut cpBody,
        count: libc::c_int,
        verts: *const cpVect,
        radius: cpFloat,
    ) -> *mut cpPolyShape;
}
extern "C" {
    #[doc = " Allocate and initialize a polygon shape with rounded corners."]
    #[doc = " A convex hull will be created from the vertexes."]
    pub fn cpPolyShapeNew(
        body: *mut cpBody,
        count: libc::c_int,
        verts: *const cpVect,
        transform: cpTransform,
        radius: cpFloat,
    ) -> *mut cpShape;
}
extern "C" {
    #[doc = " Allocate and initialize a polygon shape with rounded corners."]
    #[doc = " The vertexes must be convex with a counter-clockwise winding."]
    pub fn cpPolyShapeNewRaw(
        body: *mut cpBody,
        count: libc::c_int,
        verts: *const cpVect,
        radius: cpFloat,
    ) -> *mut cpShape;
}
extern "C" {
    #[doc = " Initialize a box shaped polygon shape with rounded corners."]
    pub fn cpBoxShapeInit(
        poly: *mut cpPolyShape,
        body: *mut cpBody,
        width: cpFloat,
        height: cpFloat,
        radius: cpFloat,
    ) -> *mut cpPolyShape;
}
extern "C" {
    #[doc = " Initialize an offset box shaped polygon shape with rounded corners."]
    pub fn cpBoxShapeInit2(
        poly: *mut cpPolyShape,
        body: *mut cpBody,
        box_: cpBB,
        radius: cpFloat,
    ) -> *mut cpPolyShape;
}
extern "C" {
    #[doc = " Allocate and initialize a box shaped polygon shape."]
    pub fn cpBoxShapeNew(
        body: *mut cpBody,
        width: cpFloat,
        height: cpFloat,
        radius: cpFloat,
    ) -> *mut cpShape;
}
extern "C" {
    #[doc = " Allocate and initialize an offset box shaped polygon shape."]
    pub fn cpBoxShapeNew2(body: *mut cpBody, box_: cpBB, radius: cpFloat) -> *mut cpShape;
}
extern "C" {
    #[doc = " Get the number of verts in a polygon shape."]
    pub fn cpPolyShapeGetCount(shape: *const cpShape) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the @c ith vertex of a polygon shape."]
    pub fn cpPolyShapeGetVert(shape: *const cpShape, index: libc::c_int) -> cpVect;
}
extern "C" {
    #[doc = " Get the radius of a polygon shape."]
    pub fn cpPolyShapeGetRadius(shape: *const cpShape) -> cpFloat;
}
#[doc = " Callback function type that gets called before solving a joint."]
pub type cpConstraintPreSolveFunc = ::core::option::Option<
    unsafe extern "C" fn(constraint: *mut cpConstraint, space: *mut cpSpace),
>;
#[doc = " Callback function type that gets called after solving a joint."]
pub type cpConstraintPostSolveFunc = ::core::option::Option<
    unsafe extern "C" fn(constraint: *mut cpConstraint, space: *mut cpSpace),
>;
extern "C" {
    #[doc = " Destroy a constraint."]
    pub fn cpConstraintDestroy(constraint: *mut cpConstraint);
}
extern "C" {
    #[doc = " Destroy and free a constraint."]
    pub fn cpConstraintFree(constraint: *mut cpConstraint);
}
extern "C" {
    #[doc = " Get the cpSpace this constraint is added to."]
    pub fn cpConstraintGetSpace(constraint: *const cpConstraint) -> *mut cpSpace;
}
extern "C" {
    #[doc = " Get the first body the constraint is attached to."]
    pub fn cpConstraintGetBodyA(constraint: *const cpConstraint) -> *mut cpBody;
}
extern "C" {
    #[doc = " Get the second body the constraint is attached to."]
    pub fn cpConstraintGetBodyB(constraint: *const cpConstraint) -> *mut cpBody;
}
extern "C" {
    #[doc = " Get the maximum force that this constraint is allowed to use."]
    pub fn cpConstraintGetMaxForce(constraint: *const cpConstraint) -> cpFloat;
}
extern "C" {
    #[doc = " Set the maximum force that this constraint is allowed to use. (defaults to INFINITY)"]
    pub fn cpConstraintSetMaxForce(constraint: *mut cpConstraint, maxForce: cpFloat);
}
extern "C" {
    #[doc = " Get rate at which joint error is corrected."]
    pub fn cpConstraintGetErrorBias(constraint: *const cpConstraint) -> cpFloat;
}
extern "C" {
    #[doc = " Set rate at which joint error is corrected."]
    #[doc = " Defaults to pow(1.0 - 0.1, 60.0) meaning that it will"]
    #[doc = " correct 10% of the error every 1/60th of a second."]
    pub fn cpConstraintSetErrorBias(constraint: *mut cpConstraint, errorBias: cpFloat);
}
extern "C" {
    #[doc = " Get the maximum rate at which joint error is corrected."]
    pub fn cpConstraintGetMaxBias(constraint: *const cpConstraint) -> cpFloat;
}
extern "C" {
    #[doc = " Set the maximum rate at which joint error is corrected. (defaults to INFINITY)"]
    pub fn cpConstraintSetMaxBias(constraint: *mut cpConstraint, maxBias: cpFloat);
}
extern "C" {
    #[doc = " Get if the two bodies connected by the constraint are allowed to collide or not."]
    pub fn cpConstraintGetCollideBodies(constraint: *const cpConstraint) -> cpBool;
}
extern "C" {
    #[doc = " Set if the two bodies connected by the constraint are allowed to collide or not. (defaults to cpFalse)"]
    pub fn cpConstraintSetCollideBodies(constraint: *mut cpConstraint, collideBodies: cpBool);
}
extern "C" {
    #[doc = " Get the pre-solve function that is called before the solver runs."]
    pub fn cpConstraintGetPreSolveFunc(constraint: *const cpConstraint)
        -> cpConstraintPreSolveFunc;
}
extern "C" {
    #[doc = " Set the pre-solve function that is called before the solver runs."]
    pub fn cpConstraintSetPreSolveFunc(
        constraint: *mut cpConstraint,
        preSolveFunc: cpConstraintPreSolveFunc,
    );
}
extern "C" {
    #[doc = " Get the post-solve function that is called before the solver runs."]
    pub fn cpConstraintGetPostSolveFunc(
        constraint: *const cpConstraint,
    ) -> cpConstraintPostSolveFunc;
}
extern "C" {
    #[doc = " Set the post-solve function that is called before the solver runs."]
    pub fn cpConstraintSetPostSolveFunc(
        constraint: *mut cpConstraint,
        postSolveFunc: cpConstraintPostSolveFunc,
    );
}
extern "C" {
    #[doc = " Get the user definable data pointer for this constraint"]
    pub fn cpConstraintGetUserData(constraint: *const cpConstraint) -> cpDataPointer;
}
extern "C" {
    #[doc = " Set the user definable data pointer for this constraint"]
    pub fn cpConstraintSetUserData(constraint: *mut cpConstraint, userData: cpDataPointer);
}
extern "C" {
    #[doc = " Get the last impulse applied by this constraint."]
    pub fn cpConstraintGetImpulse(constraint: *mut cpConstraint) -> cpFloat;
}
extern "C" {
    #[doc = " Check if a constraint is a pin joint."]
    pub fn cpConstraintIsPinJoint(constraint: *const cpConstraint) -> cpBool;
}
extern "C" {
    #[doc = " Allocate a pin joint."]
    pub fn cpPinJointAlloc() -> *mut cpPinJoint;
}
extern "C" {
    #[doc = " Initialize a pin joint."]
    pub fn cpPinJointInit(
        joint: *mut cpPinJoint,
        a: *mut cpBody,
        b: *mut cpBody,
        anchorA: cpVect,
        anchorB: cpVect,
    ) -> *mut cpPinJoint;
}
extern "C" {
    #[doc = " Allocate and initialize a pin joint."]
    pub fn cpPinJointNew(
        a: *mut cpBody,
        b: *mut cpBody,
        anchorA: cpVect,
        anchorB: cpVect,
    ) -> *mut cpConstraint;
}
extern "C" {
    #[doc = " Get the location of the first anchor relative to the first body."]
    pub fn cpPinJointGetAnchorA(constraint: *const cpConstraint) -> cpVect;
}
extern "C" {
    #[doc = " Set the location of the first anchor relative to the first body."]
    pub fn cpPinJointSetAnchorA(constraint: *mut cpConstraint, anchorA: cpVect);
}
extern "C" {
    #[doc = " Get the location of the second anchor relative to the second body."]
    pub fn cpPinJointGetAnchorB(constraint: *const cpConstraint) -> cpVect;
}
extern "C" {
    #[doc = " Set the location of the second anchor relative to the second body."]
    pub fn cpPinJointSetAnchorB(constraint: *mut cpConstraint, anchorB: cpVect);
}
extern "C" {
    #[doc = " Get the distance the joint will maintain between the two anchors."]
    pub fn cpPinJointGetDist(constraint: *const cpConstraint) -> cpFloat;
}
extern "C" {
    #[doc = " Set the distance the joint will maintain between the two anchors."]
    pub fn cpPinJointSetDist(constraint: *mut cpConstraint, dist: cpFloat);
}
extern "C" {
    #[doc = " Check if a constraint is a slide joint."]
    pub fn cpConstraintIsSlideJoint(constraint: *const cpConstraint) -> cpBool;
}
extern "C" {
    #[doc = " Allocate a slide joint."]
    pub fn cpSlideJointAlloc() -> *mut cpSlideJoint;
}
extern "C" {
    #[doc = " Initialize a slide joint."]
    pub fn cpSlideJointInit(
        joint: *mut cpSlideJoint,
        a: *mut cpBody,
        b: *mut cpBody,
        anchorA: cpVect,
        anchorB: cpVect,
        min: cpFloat,
        max: cpFloat,
    ) -> *mut cpSlideJoint;
}
extern "C" {
    #[doc = " Allocate and initialize a slide joint."]
    pub fn cpSlideJointNew(
        a: *mut cpBody,
        b: *mut cpBody,
        anchorA: cpVect,
        anchorB: cpVect,
        min: cpFloat,
        max: cpFloat,
    ) -> *mut cpConstraint;
}
extern "C" {
    #[doc = " Get the location of the first anchor relative to the first body."]
    pub fn cpSlideJointGetAnchorA(constraint: *const cpConstraint) -> cpVect;
}
extern "C" {
    #[doc = " Set the location of the first anchor relative to the first body."]
    pub fn cpSlideJointSetAnchorA(constraint: *mut cpConstraint, anchorA: cpVect);
}
extern "C" {
    #[doc = " Get the location of the second anchor relative to the second body."]
    pub fn cpSlideJointGetAnchorB(constraint: *const cpConstraint) -> cpVect;
}
extern "C" {
    #[doc = " Set the location of the second anchor relative to the second body."]
    pub fn cpSlideJointSetAnchorB(constraint: *mut cpConstraint, anchorB: cpVect);
}
extern "C" {
    #[doc = " Get the minimum distance the joint will maintain between the two anchors."]
    pub fn cpSlideJointGetMin(constraint: *const cpConstraint) -> cpFloat;
}
extern "C" {
    #[doc = " Set the minimum distance the joint will maintain between the two anchors."]
    pub fn cpSlideJointSetMin(constraint: *mut cpConstraint, min: cpFloat);
}
extern "C" {
    #[doc = " Get the maximum distance the joint will maintain between the two anchors."]
    pub fn cpSlideJointGetMax(constraint: *const cpConstraint) -> cpFloat;
}
extern "C" {
    #[doc = " Set the maximum distance the joint will maintain between the two anchors."]
    pub fn cpSlideJointSetMax(constraint: *mut cpConstraint, max: cpFloat);
}
extern "C" {
    #[doc = " Check if a constraint is a slide joint."]
    pub fn cpConstraintIsPivotJoint(constraint: *const cpConstraint) -> cpBool;
}
extern "C" {
    #[doc = " Allocate a pivot joint"]
    pub fn cpPivotJointAlloc() -> *mut cpPivotJoint;
}
extern "C" {
    #[doc = " Initialize a pivot joint."]
    pub fn cpPivotJointInit(
        joint: *mut cpPivotJoint,
        a: *mut cpBody,
        b: *mut cpBody,
        anchorA: cpVect,
        anchorB: cpVect,
    ) -> *mut cpPivotJoint;
}
extern "C" {
    #[doc = " Allocate and initialize a pivot joint."]
    pub fn cpPivotJointNew(a: *mut cpBody, b: *mut cpBody, pivot: cpVect) -> *mut cpConstraint;
}
extern "C" {
    #[doc = " Allocate and initialize a pivot joint with specific anchors."]
    pub fn cpPivotJointNew2(
        a: *mut cpBody,
        b: *mut cpBody,
        anchorA: cpVect,
        anchorB: cpVect,
    ) -> *mut cpConstraint;
}
extern "C" {
    #[doc = " Get the location of the first anchor relative to the first body."]
    pub fn cpPivotJointGetAnchorA(constraint: *const cpConstraint) -> cpVect;
}
extern "C" {
    #[doc = " Set the location of the first anchor relative to the first body."]
    pub fn cpPivotJointSetAnchorA(constraint: *mut cpConstraint, anchorA: cpVect);
}
extern "C" {
    #[doc = " Get the location of the second anchor relative to the second body."]
    pub fn cpPivotJointGetAnchorB(constraint: *const cpConstraint) -> cpVect;
}
extern "C" {
    #[doc = " Set the location of the second anchor relative to the second body."]
    pub fn cpPivotJointSetAnchorB(constraint: *mut cpConstraint, anchorB: cpVect);
}
extern "C" {
    #[doc = " Check if a constraint is a slide joint."]
    pub fn cpConstraintIsGrooveJoint(constraint: *const cpConstraint) -> cpBool;
}
extern "C" {
    #[doc = " Allocate a groove joint."]
    pub fn cpGrooveJointAlloc() -> *mut cpGrooveJoint;
}
extern "C" {
    #[doc = " Initialize a groove joint."]
    pub fn cpGrooveJointInit(
        joint: *mut cpGrooveJoint,
        a: *mut cpBody,
        b: *mut cpBody,
        groove_a: cpVect,
        groove_b: cpVect,
        anchorB: cpVect,
    ) -> *mut cpGrooveJoint;
}
extern "C" {
    #[doc = " Allocate and initialize a groove joint."]
    pub fn cpGrooveJointNew(
        a: *mut cpBody,
        b: *mut cpBody,
        groove_a: cpVect,
        groove_b: cpVect,
        anchorB: cpVect,
    ) -> *mut cpConstraint;
}
extern "C" {
    #[doc = " Get the first endpoint of the groove relative to the first body."]
    pub fn cpGrooveJointGetGrooveA(constraint: *const cpConstraint) -> cpVect;
}
extern "C" {
    #[doc = " Set the first endpoint of the groove relative to the first body."]
    pub fn cpGrooveJointSetGrooveA(constraint: *mut cpConstraint, grooveA: cpVect);
}
extern "C" {
    #[doc = " Get the first endpoint of the groove relative to the first body."]
    pub fn cpGrooveJointGetGrooveB(constraint: *const cpConstraint) -> cpVect;
}
extern "C" {
    #[doc = " Set the first endpoint of the groove relative to the first body."]
    pub fn cpGrooveJointSetGrooveB(constraint: *mut cpConstraint, grooveB: cpVect);
}
extern "C" {
    #[doc = " Get the location of the second anchor relative to the second body."]
    pub fn cpGrooveJointGetAnchorB(constraint: *const cpConstraint) -> cpVect;
}
extern "C" {
    #[doc = " Set the location of the second anchor relative to the second body."]
    pub fn cpGrooveJointSetAnchorB(constraint: *mut cpConstraint, anchorB: cpVect);
}
extern "C" {
    #[doc = " Check if a constraint is a slide joint."]
    pub fn cpConstraintIsDampedSpring(constraint: *const cpConstraint) -> cpBool;
}
#[doc = " Function type used for damped spring force callbacks."]
pub type cpDampedSpringForceFunc = ::core::option::Option<
    unsafe extern "C" fn(spring: *mut cpConstraint, dist: cpFloat) -> cpFloat,
>;
extern "C" {
    #[doc = " Allocate a damped spring."]
    pub fn cpDampedSpringAlloc() -> *mut cpDampedSpring;
}
extern "C" {
    #[doc = " Initialize a damped spring."]
    pub fn cpDampedSpringInit(
        joint: *mut cpDampedSpring,
        a: *mut cpBody,
        b: *mut cpBody,
        anchorA: cpVect,
        anchorB: cpVect,
        restLength: cpFloat,
        stiffness: cpFloat,
        damping: cpFloat,
    ) -> *mut cpDampedSpring;
}
extern "C" {
    #[doc = " Allocate and initialize a damped spring."]
    pub fn cpDampedSpringNew(
        a: *mut cpBody,
        b: *mut cpBody,
        anchorA: cpVect,
        anchorB: cpVect,
        restLength: cpFloat,
        stiffness: cpFloat,
        damping: cpFloat,
    ) -> *mut cpConstraint;
}
extern "C" {
    #[doc = " Get the location of the first anchor relative to the first body."]
    pub fn cpDampedSpringGetAnchorA(constraint: *const cpConstraint) -> cpVect;
}
extern "C" {
    #[doc = " Set the location of the first anchor relative to the first body."]
    pub fn cpDampedSpringSetAnchorA(constraint: *mut cpConstraint, anchorA: cpVect);
}
extern "C" {
    #[doc = " Get the location of the second anchor relative to the second body."]
    pub fn cpDampedSpringGetAnchorB(constraint: *const cpConstraint) -> cpVect;
}
extern "C" {
    #[doc = " Set the location of the second anchor relative to the second body."]
    pub fn cpDampedSpringSetAnchorB(constraint: *mut cpConstraint, anchorB: cpVect);
}
extern "C" {
    #[doc = " Get the rest length of the spring."]
    pub fn cpDampedSpringGetRestLength(constraint: *const cpConstraint) -> cpFloat;
}
extern "C" {
    #[doc = " Set the rest length of the spring."]
    pub fn cpDampedSpringSetRestLength(constraint: *mut cpConstraint, restLength: cpFloat);
}
extern "C" {
    #[doc = " Get the stiffness of the spring in force/distance."]
    pub fn cpDampedSpringGetStiffness(constraint: *const cpConstraint) -> cpFloat;
}
extern "C" {
    #[doc = " Set the stiffness of the spring in force/distance."]
    pub fn cpDampedSpringSetStiffness(constraint: *mut cpConstraint, stiffness: cpFloat);
}
extern "C" {
    #[doc = " Get the damping of the spring."]
    pub fn cpDampedSpringGetDamping(constraint: *const cpConstraint) -> cpFloat;
}
extern "C" {
    #[doc = " Set the damping of the spring."]
    pub fn cpDampedSpringSetDamping(constraint: *mut cpConstraint, damping: cpFloat);
}
extern "C" {
    #[doc = " Get the damping of the spring."]
    pub fn cpDampedSpringGetSpringForceFunc(
        constraint: *const cpConstraint,
    ) -> cpDampedSpringForceFunc;
}
extern "C" {
    #[doc = " Set the damping of the spring."]
    pub fn cpDampedSpringSetSpringForceFunc(
        constraint: *mut cpConstraint,
        springForceFunc: cpDampedSpringForceFunc,
    );
}
extern "C" {
    #[doc = " Check if a constraint is a damped rotary springs."]
    pub fn cpConstraintIsDampedRotarySpring(constraint: *const cpConstraint) -> cpBool;
}
#[doc = " Function type used for damped rotary spring force callbacks."]
pub type cpDampedRotarySpringTorqueFunc = ::core::option::Option<
    unsafe extern "C" fn(spring: *mut cpConstraint, relativeAngle: cpFloat) -> cpFloat,
>;
extern "C" {
    #[doc = " Allocate a damped rotary spring."]
    pub fn cpDampedRotarySpringAlloc() -> *mut cpDampedRotarySpring;
}
extern "C" {
    #[doc = " Initialize a damped rotary spring."]
    pub fn cpDampedRotarySpringInit(
        joint: *mut cpDampedRotarySpring,
        a: *mut cpBody,
        b: *mut cpBody,
        restAngle: cpFloat,
        stiffness: cpFloat,
        damping: cpFloat,
    ) -> *mut cpDampedRotarySpring;
}
extern "C" {
    #[doc = " Allocate and initialize a damped rotary spring."]
    pub fn cpDampedRotarySpringNew(
        a: *mut cpBody,
        b: *mut cpBody,
        restAngle: cpFloat,
        stiffness: cpFloat,
        damping: cpFloat,
    ) -> *mut cpConstraint;
}
extern "C" {
    #[doc = " Get the rest length of the spring."]
    pub fn cpDampedRotarySpringGetRestAngle(constraint: *const cpConstraint) -> cpFloat;
}
extern "C" {
    #[doc = " Set the rest length of the spring."]
    pub fn cpDampedRotarySpringSetRestAngle(constraint: *mut cpConstraint, restAngle: cpFloat);
}
extern "C" {
    #[doc = " Get the stiffness of the spring in force/distance."]
    pub fn cpDampedRotarySpringGetStiffness(constraint: *const cpConstraint) -> cpFloat;
}
extern "C" {
    #[doc = " Set the stiffness of the spring in force/distance."]
    pub fn cpDampedRotarySpringSetStiffness(constraint: *mut cpConstraint, stiffness: cpFloat);
}
extern "C" {
    #[doc = " Get the damping of the spring."]
    pub fn cpDampedRotarySpringGetDamping(constraint: *const cpConstraint) -> cpFloat;
}
extern "C" {
    #[doc = " Set the damping of the spring."]
    pub fn cpDampedRotarySpringSetDamping(constraint: *mut cpConstraint, damping: cpFloat);
}
extern "C" {
    #[doc = " Get the damping of the spring."]
    pub fn cpDampedRotarySpringGetSpringTorqueFunc(
        constraint: *const cpConstraint,
    ) -> cpDampedRotarySpringTorqueFunc;
}
extern "C" {
    #[doc = " Set the damping of the spring."]
    pub fn cpDampedRotarySpringSetSpringTorqueFunc(
        constraint: *mut cpConstraint,
        springTorqueFunc: cpDampedRotarySpringTorqueFunc,
    );
}
extern "C" {
    #[doc = " Check if a constraint is a damped rotary springs."]
    pub fn cpConstraintIsRotaryLimitJoint(constraint: *const cpConstraint) -> cpBool;
}
extern "C" {
    #[doc = " Allocate a damped rotary limit joint."]
    pub fn cpRotaryLimitJointAlloc() -> *mut cpRotaryLimitJoint;
}
extern "C" {
    #[doc = " Initialize a damped rotary limit joint."]
    pub fn cpRotaryLimitJointInit(
        joint: *mut cpRotaryLimitJoint,
        a: *mut cpBody,
        b: *mut cpBody,
        min: cpFloat,
        max: cpFloat,
    ) -> *mut cpRotaryLimitJoint;
}
extern "C" {
    #[doc = " Allocate and initialize a damped rotary limit joint."]
    pub fn cpRotaryLimitJointNew(
        a: *mut cpBody,
        b: *mut cpBody,
        min: cpFloat,
        max: cpFloat,
    ) -> *mut cpConstraint;
}
extern "C" {
    #[doc = " Get the minimum distance the joint will maintain between the two anchors."]
    pub fn cpRotaryLimitJointGetMin(constraint: *const cpConstraint) -> cpFloat;
}
extern "C" {
    #[doc = " Set the minimum distance the joint will maintain between the two anchors."]
    pub fn cpRotaryLimitJointSetMin(constraint: *mut cpConstraint, min: cpFloat);
}
extern "C" {
    #[doc = " Get the maximum distance the joint will maintain between the two anchors."]
    pub fn cpRotaryLimitJointGetMax(constraint: *const cpConstraint) -> cpFloat;
}
extern "C" {
    #[doc = " Set the maximum distance the joint will maintain between the two anchors."]
    pub fn cpRotaryLimitJointSetMax(constraint: *mut cpConstraint, max: cpFloat);
}
extern "C" {
    #[doc = " Check if a constraint is a damped rotary springs."]
    pub fn cpConstraintIsRatchetJoint(constraint: *const cpConstraint) -> cpBool;
}
extern "C" {
    #[doc = " Allocate a ratchet joint."]
    pub fn cpRatchetJointAlloc() -> *mut cpRatchetJoint;
}
extern "C" {
    #[doc = " Initialize a ratched joint."]
    pub fn cpRatchetJointInit(
        joint: *mut cpRatchetJoint,
        a: *mut cpBody,
        b: *mut cpBody,
        phase: cpFloat,
        ratchet: cpFloat,
    ) -> *mut cpRatchetJoint;
}
extern "C" {
    #[doc = " Allocate and initialize a ratchet joint."]
    pub fn cpRatchetJointNew(
        a: *mut cpBody,
        b: *mut cpBody,
        phase: cpFloat,
        ratchet: cpFloat,
    ) -> *mut cpConstraint;
}
extern "C" {
    #[doc = " Get the angle of the current ratchet tooth."]
    pub fn cpRatchetJointGetAngle(constraint: *const cpConstraint) -> cpFloat;
}
extern "C" {
    #[doc = " Set the angle of the current ratchet tooth."]
    pub fn cpRatchetJointSetAngle(constraint: *mut cpConstraint, angle: cpFloat);
}
extern "C" {
    #[doc = " Get the phase offset of the ratchet."]
    pub fn cpRatchetJointGetPhase(constraint: *const cpConstraint) -> cpFloat;
}
extern "C" {
    #[doc = " Get the phase offset of the ratchet."]
    pub fn cpRatchetJointSetPhase(constraint: *mut cpConstraint, phase: cpFloat);
}
extern "C" {
    #[doc = " Get the angular distance of each ratchet."]
    pub fn cpRatchetJointGetRatchet(constraint: *const cpConstraint) -> cpFloat;
}
extern "C" {
    #[doc = " Set the angular distance of each ratchet."]
    pub fn cpRatchetJointSetRatchet(constraint: *mut cpConstraint, ratchet: cpFloat);
}
extern "C" {
    #[doc = " Check if a constraint is a damped rotary springs."]
    pub fn cpConstraintIsGearJoint(constraint: *const cpConstraint) -> cpBool;
}
extern "C" {
    #[doc = " Allocate a gear joint."]
    pub fn cpGearJointAlloc() -> *mut cpGearJoint;
}
extern "C" {
    #[doc = " Initialize a gear joint."]
    pub fn cpGearJointInit(
        joint: *mut cpGearJoint,
        a: *mut cpBody,
        b: *mut cpBody,
        phase: cpFloat,
        ratio: cpFloat,
    ) -> *mut cpGearJoint;
}
extern "C" {
    #[doc = " Allocate and initialize a gear joint."]
    pub fn cpGearJointNew(
        a: *mut cpBody,
        b: *mut cpBody,
        phase: cpFloat,
        ratio: cpFloat,
    ) -> *mut cpConstraint;
}
extern "C" {
    #[doc = " Get the phase offset of the gears."]
    pub fn cpGearJointGetPhase(constraint: *const cpConstraint) -> cpFloat;
}
extern "C" {
    #[doc = " Set the phase offset of the gears."]
    pub fn cpGearJointSetPhase(constraint: *mut cpConstraint, phase: cpFloat);
}
extern "C" {
    #[doc = " Get the angular distance of each ratchet."]
    pub fn cpGearJointGetRatio(constraint: *const cpConstraint) -> cpFloat;
}
extern "C" {
    #[doc = " Set the ratio of a gear joint."]
    pub fn cpGearJointSetRatio(constraint: *mut cpConstraint, ratio: cpFloat);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cpSimpleMotor {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Check if a constraint is a damped rotary springs."]
    pub fn cpConstraintIsSimpleMotor(constraint: *const cpConstraint) -> cpBool;
}
extern "C" {
    #[doc = " Allocate a simple motor."]
    pub fn cpSimpleMotorAlloc() -> *mut cpSimpleMotor;
}
extern "C" {
    #[doc = " initialize a simple motor."]
    pub fn cpSimpleMotorInit(
        joint: *mut cpSimpleMotor,
        a: *mut cpBody,
        b: *mut cpBody,
        rate: cpFloat,
    ) -> *mut cpSimpleMotor;
}
extern "C" {
    #[doc = " Allocate and initialize a simple motor."]
    pub fn cpSimpleMotorNew(a: *mut cpBody, b: *mut cpBody, rate: cpFloat) -> *mut cpConstraint;
}
extern "C" {
    #[doc = " Get the rate of the motor."]
    pub fn cpSimpleMotorGetRate(constraint: *const cpConstraint) -> cpFloat;
}
extern "C" {
    #[doc = " Set the rate of the motor."]
    pub fn cpSimpleMotorSetRate(constraint: *mut cpConstraint, rate: cpFloat);
}
#[doc = " Collision begin event function callback type."]
#[doc = " Returning false from a begin callback causes the collision to be ignored until"]
#[doc = " the the separate callback is called when the objects stop colliding."]
pub type cpCollisionBeginFunc = ::core::option::Option<
    unsafe extern "C" fn(
        arb: *mut cpArbiter,
        space: *mut cpSpace,
        userData: cpDataPointer,
    ) -> cpBool,
>;
#[doc = " Collision pre-solve event function callback type."]
#[doc = " Returning false from a pre-step callback causes the collision to be ignored until the next step."]
pub type cpCollisionPreSolveFunc = ::core::option::Option<
    unsafe extern "C" fn(
        arb: *mut cpArbiter,
        space: *mut cpSpace,
        userData: cpDataPointer,
    ) -> cpBool,
>;
#[doc = " Collision post-solve event function callback type."]
pub type cpCollisionPostSolveFunc = ::core::option::Option<
    unsafe extern "C" fn(arb: *mut cpArbiter, space: *mut cpSpace, userData: cpDataPointer),
>;
#[doc = " Collision separate event function callback type."]
pub type cpCollisionSeparateFunc = ::core::option::Option<
    unsafe extern "C" fn(arb: *mut cpArbiter, space: *mut cpSpace, userData: cpDataPointer),
>;
#[doc = " Struct that holds function callback pointers to configure custom collision handling."]
#[doc = " Collision handlers have a pair of types; when a collision occurs between two shapes that have these types, the collision handler functions are triggered."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cpCollisionHandler {
    #[doc = " Collision type identifier of the first shape that this handler recognizes."]
    #[doc = " In the collision handler callback, the shape with this type will be the first argument. Read only."]
    pub typeA: cpCollisionType,
    #[doc = " Collision type identifier of the second shape that this handler recognizes."]
    #[doc = " In the collision handler callback, the shape with this type will be the second argument. Read only."]
    pub typeB: cpCollisionType,
    #[doc = " This function is called when two shapes with types that match this collision handler begin colliding."]
    pub beginFunc: cpCollisionBeginFunc,
    #[doc = " This function is called each step when two shapes with types that match this collision handler are colliding."]
    #[doc = " It's called before the collision solver runs so that you can affect a collision's outcome."]
    pub preSolveFunc: cpCollisionPreSolveFunc,
    #[doc = " This function is called each step when two shapes with types that match this collision handler are colliding."]
    #[doc = " It's called after the collision solver runs so that you can read back information about the collision to trigger events in your game."]
    pub postSolveFunc: cpCollisionPostSolveFunc,
    #[doc = " This function is called when two shapes with types that match this collision handler stop colliding."]
    pub separateFunc: cpCollisionSeparateFunc,
    #[doc = " This is a user definable context pointer that is passed to all of the collision handler functions."]
    pub userData: cpDataPointer,
}
#[test]
fn bindgen_test_layout_cpCollisionHandler() {
    assert_eq!(
        ::core::mem::size_of::<cpCollisionHandler>(),
        56usize,
        concat!("Size of: ", stringify!(cpCollisionHandler))
    );
    assert_eq!(
        ::core::mem::align_of::<cpCollisionHandler>(),
        8usize,
        concat!("Alignment of ", stringify!(cpCollisionHandler))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cpCollisionHandler>())).typeA as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cpCollisionHandler),
            "::",
            stringify!(typeA)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cpCollisionHandler>())).typeB as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cpCollisionHandler),
            "::",
            stringify!(typeB)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cpCollisionHandler>())).beginFunc as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cpCollisionHandler),
            "::",
            stringify!(beginFunc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<cpCollisionHandler>())).preSolveFunc as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cpCollisionHandler),
            "::",
            stringify!(preSolveFunc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<cpCollisionHandler>())).postSolveFunc as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cpCollisionHandler),
            "::",
            stringify!(postSolveFunc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<cpCollisionHandler>())).separateFunc as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cpCollisionHandler),
            "::",
            stringify!(separateFunc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cpCollisionHandler>())).userData as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(cpCollisionHandler),
            "::",
            stringify!(userData)
        )
    );
}
extern "C" {
    #[doc = " Allocate a cpSpace."]
    pub fn cpSpaceAlloc() -> *mut cpSpace;
}
extern "C" {
    #[doc = " Initialize a cpSpace."]
    pub fn cpSpaceInit(space: *mut cpSpace) -> *mut cpSpace;
}
extern "C" {
    #[doc = " Allocate and initialize a cpSpace."]
    pub fn cpSpaceNew() -> *mut cpSpace;
}
extern "C" {
    #[doc = " Destroy a cpSpace."]
    pub fn cpSpaceDestroy(space: *mut cpSpace);
}
extern "C" {
    #[doc = " Destroy and free a cpSpace."]
    pub fn cpSpaceFree(space: *mut cpSpace);
}
extern "C" {
    #[doc = " Number of iterations to use in the impulse solver to solve contacts and other constraints."]
    pub fn cpSpaceGetIterations(space: *const cpSpace) -> libc::c_int;
}
extern "C" {
    pub fn cpSpaceSetIterations(space: *mut cpSpace, iterations: libc::c_int);
}
extern "C" {
    #[doc = " Gravity to pass to rigid bodies when integrating velocity."]
    pub fn cpSpaceGetGravity(space: *const cpSpace) -> cpVect;
}
extern "C" {
    pub fn cpSpaceSetGravity(space: *mut cpSpace, gravity: cpVect);
}
extern "C" {
    #[doc = " Damping rate expressed as the fraction of velocity bodies retain each second."]
    #[doc = " A value of 0.9 would mean that each body's velocity will drop 10% per second."]
    #[doc = " The default value is 1.0, meaning no damping is applied."]
    #[doc = " @note This damping value is different than those of cpDampedSpring and cpDampedRotarySpring."]
    pub fn cpSpaceGetDamping(space: *const cpSpace) -> cpFloat;
}
extern "C" {
    pub fn cpSpaceSetDamping(space: *mut cpSpace, damping: cpFloat);
}
extern "C" {
    #[doc = " Speed threshold for a body to be considered idle."]
    #[doc = " The default value of 0 means to let the space guess a good threshold based on gravity."]
    pub fn cpSpaceGetIdleSpeedThreshold(space: *const cpSpace) -> cpFloat;
}
extern "C" {
    pub fn cpSpaceSetIdleSpeedThreshold(space: *mut cpSpace, idleSpeedThreshold: cpFloat);
}
extern "C" {
    #[doc = " Time a group of bodies must remain idle in order to fall asleep."]
    #[doc = " Enabling sleeping also implicitly enables the the contact graph."]
    #[doc = " The default value of INFINITY disables the sleeping algorithm."]
    pub fn cpSpaceGetSleepTimeThreshold(space: *const cpSpace) -> cpFloat;
}
extern "C" {
    pub fn cpSpaceSetSleepTimeThreshold(space: *mut cpSpace, sleepTimeThreshold: cpFloat);
}
extern "C" {
    #[doc = " Amount of encouraged penetration between colliding shapes."]
    #[doc = " Used to reduce oscillating contacts and keep the collision cache warm."]
    #[doc = " Defaults to 0.1. If you have poor simulation quality,"]
    #[doc = " increase this number as much as possible without allowing visible amounts of overlap."]
    pub fn cpSpaceGetCollisionSlop(space: *const cpSpace) -> cpFloat;
}
extern "C" {
    pub fn cpSpaceSetCollisionSlop(space: *mut cpSpace, collisionSlop: cpFloat);
}
extern "C" {
    #[doc = " Determines how fast overlapping shapes are pushed apart."]
    #[doc = " Expressed as a fraction of the error remaining after each second."]
    #[doc = " Defaults to pow(1.0 - 0.1, 60.0) meaning that Chipmunk fixes 10% of overlap each frame at 60Hz."]
    pub fn cpSpaceGetCollisionBias(space: *const cpSpace) -> cpFloat;
}
extern "C" {
    pub fn cpSpaceSetCollisionBias(space: *mut cpSpace, collisionBias: cpFloat);
}
extern "C" {
    #[doc = " Number of frames that contact information should persist."]
    #[doc = " Defaults to 3. There is probably never a reason to change this value."]
    pub fn cpSpaceGetCollisionPersistence(space: *const cpSpace) -> cpTimestamp;
}
extern "C" {
    pub fn cpSpaceSetCollisionPersistence(space: *mut cpSpace, collisionPersistence: cpTimestamp);
}
extern "C" {
    #[doc = " User definable data pointer."]
    #[doc = " Generally this points to your game's controller or game state"]
    #[doc = " class so you can access it when given a cpSpace reference in a callback."]
    pub fn cpSpaceGetUserData(space: *const cpSpace) -> cpDataPointer;
}
extern "C" {
    pub fn cpSpaceSetUserData(space: *mut cpSpace, userData: cpDataPointer);
}
extern "C" {
    #[doc = " The Space provided static body for a given cpSpace."]
    #[doc = " This is merely provided for convenience and you are not required to use it."]
    pub fn cpSpaceGetStaticBody(space: *const cpSpace) -> *mut cpBody;
}
extern "C" {
    #[doc = " Returns the current (or most recent) time step used with the given space."]
    #[doc = " Useful from callbacks if your time step is not a compile-time global."]
    pub fn cpSpaceGetCurrentTimeStep(space: *const cpSpace) -> cpFloat;
}
extern "C" {
    #[doc = " returns true from inside a callback when objects cannot be added/removed."]
    pub fn cpSpaceIsLocked(space: *mut cpSpace) -> cpBool;
}
extern "C" {
    #[doc = " Create or return the existing collision handler that is called for all collisions that are not handled by a more specific collision handler."]
    pub fn cpSpaceAddDefaultCollisionHandler(space: *mut cpSpace) -> *mut cpCollisionHandler;
}
extern "C" {
    #[doc = " Create or return the existing collision handler for the specified pair of collision types."]
    #[doc = " If wildcard handlers are used with either of the collision types, it's the responibility of the custom handler to invoke the wildcard handlers."]
    pub fn cpSpaceAddCollisionHandler(
        space: *mut cpSpace,
        a: cpCollisionType,
        b: cpCollisionType,
    ) -> *mut cpCollisionHandler;
}
extern "C" {
    #[doc = " Create or return the existing wildcard collision handler for the specified type."]
    pub fn cpSpaceAddWildcardHandler(
        space: *mut cpSpace,
        type_: cpCollisionType,
    ) -> *mut cpCollisionHandler;
}
extern "C" {
    #[doc = " Add a collision shape to the simulation."]
    #[doc = " If the shape is attached to a static body, it will be added as a static shape."]
    pub fn cpSpaceAddShape(space: *mut cpSpace, shape: *mut cpShape) -> *mut cpShape;
}
extern "C" {
    #[doc = " Add a rigid body to the simulation."]
    pub fn cpSpaceAddBody(space: *mut cpSpace, body: *mut cpBody) -> *mut cpBody;
}
extern "C" {
    #[doc = " Add a constraint to the simulation."]
    pub fn cpSpaceAddConstraint(
        space: *mut cpSpace,
        constraint: *mut cpConstraint,
    ) -> *mut cpConstraint;
}
extern "C" {
    #[doc = " Remove a collision shape from the simulation."]
    pub fn cpSpaceRemoveShape(space: *mut cpSpace, shape: *mut cpShape);
}
extern "C" {
    #[doc = " Remove a rigid body from the simulation."]
    pub fn cpSpaceRemoveBody(space: *mut cpSpace, body: *mut cpBody);
}
extern "C" {
    #[doc = " Remove a constraint from the simulation."]
    pub fn cpSpaceRemoveConstraint(space: *mut cpSpace, constraint: *mut cpConstraint);
}
extern "C" {
    #[doc = " Test if a collision shape has been added to the space."]
    pub fn cpSpaceContainsShape(space: *mut cpSpace, shape: *mut cpShape) -> cpBool;
}
extern "C" {
    #[doc = " Test if a rigid body has been added to the space."]
    pub fn cpSpaceContainsBody(space: *mut cpSpace, body: *mut cpBody) -> cpBool;
}
extern "C" {
    #[doc = " Test if a constraint has been added to the space."]
    pub fn cpSpaceContainsConstraint(space: *mut cpSpace, constraint: *mut cpConstraint) -> cpBool;
}
#[doc = " Post Step callback function type."]
pub type cpPostStepFunc = ::core::option::Option<
    unsafe extern "C" fn(space: *mut cpSpace, key: *mut libc::c_void, data: *mut libc::c_void),
>;
extern "C" {
    #[doc = " Schedule a post-step callback to be called when cpSpaceStep() finishes."]
    #[doc = " You can only register one callback per unique value for @c key."]
    #[doc = " Returns true only if @c key has never been scheduled before."]
    #[doc = " It's possible to pass @c NULL for @c func if you only want to mark @c key as being used."]
    pub fn cpSpaceAddPostStepCallback(
        space: *mut cpSpace,
        func: cpPostStepFunc,
        key: *mut libc::c_void,
        data: *mut libc::c_void,
    ) -> cpBool;
}
#[doc = " Nearest point query callback function type."]
pub type cpSpacePointQueryFunc = ::core::option::Option<
    unsafe extern "C" fn(
        shape: *mut cpShape,
        point: cpVect,
        distance: cpFloat,
        gradient: cpVect,
        data: *mut libc::c_void,
    ),
>;
extern "C" {
    #[doc = " Query the space at a point and call @c func for each shape found."]
    pub fn cpSpacePointQuery(
        space: *mut cpSpace,
        point: cpVect,
        maxDistance: cpFloat,
        filter: cpShapeFilter,
        func: cpSpacePointQueryFunc,
        data: *mut libc::c_void,
    );
}
extern "C" {
    #[doc = " Query the space at a point and return the nearest shape found. Returns NULL if no shapes were found."]
    pub fn cpSpacePointQueryNearest(
        space: *mut cpSpace,
        point: cpVect,
        maxDistance: cpFloat,
        filter: cpShapeFilter,
        out: *mut cpPointQueryInfo,
    ) -> *mut cpShape;
}
#[doc = " Segment query callback function type."]
pub type cpSpaceSegmentQueryFunc = ::core::option::Option<
    unsafe extern "C" fn(
        shape: *mut cpShape,
        point: cpVect,
        normal: cpVect,
        alpha: cpFloat,
        data: *mut libc::c_void,
    ),
>;
extern "C" {
    #[doc = " Perform a directed line segment query (like a raycast) against the space calling @c func for each shape intersected."]
    pub fn cpSpaceSegmentQuery(
        space: *mut cpSpace,
        start: cpVect,
        end: cpVect,
        radius: cpFloat,
        filter: cpShapeFilter,
        func: cpSpaceSegmentQueryFunc,
        data: *mut libc::c_void,
    );
}
extern "C" {
    #[doc = " Perform a directed line segment query (like a raycast) against the space and return the first shape hit. Returns NULL if no shapes were hit."]
    pub fn cpSpaceSegmentQueryFirst(
        space: *mut cpSpace,
        start: cpVect,
        end: cpVect,
        radius: cpFloat,
        filter: cpShapeFilter,
        out: *mut cpSegmentQueryInfo,
    ) -> *mut cpShape;
}
#[doc = " Rectangle Query callback function type."]
pub type cpSpaceBBQueryFunc =
    ::core::option::Option<unsafe extern "C" fn(shape: *mut cpShape, data: *mut libc::c_void)>;
extern "C" {
    #[doc = " Perform a fast rectangle query on the space calling @c func for each shape found."]
    #[doc = " Only the shape's bounding boxes are checked for overlap, not their full shape."]
    pub fn cpSpaceBBQuery(
        space: *mut cpSpace,
        bb: cpBB,
        filter: cpShapeFilter,
        func: cpSpaceBBQueryFunc,
        data: *mut libc::c_void,
    );
}
#[doc = " Shape query callback function type."]
pub type cpSpaceShapeQueryFunc = ::core::option::Option<
    unsafe extern "C" fn(
        shape: *mut cpShape,
        points: *mut cpContactPointSet,
        data: *mut libc::c_void,
    ),
>;
extern "C" {
    #[doc = " Query a space for any shapes overlapping the given shape and call @c func for each shape found."]
    pub fn cpSpaceShapeQuery(
        space: *mut cpSpace,
        shape: *mut cpShape,
        func: cpSpaceShapeQueryFunc,
        data: *mut libc::c_void,
    ) -> cpBool;
}
#[doc = " Space/body iterator callback function type."]
pub type cpSpaceBodyIteratorFunc =
    ::core::option::Option<unsafe extern "C" fn(body: *mut cpBody, data: *mut libc::c_void)>;
extern "C" {
    #[doc = " Call @c func for each body in the space."]
    pub fn cpSpaceEachBody(
        space: *mut cpSpace,
        func: cpSpaceBodyIteratorFunc,
        data: *mut libc::c_void,
    );
}
#[doc = " Space/body iterator callback function type."]
pub type cpSpaceShapeIteratorFunc =
    ::core::option::Option<unsafe extern "C" fn(shape: *mut cpShape, data: *mut libc::c_void)>;
extern "C" {
    #[doc = " Call @c func for each shape in the space."]
    pub fn cpSpaceEachShape(
        space: *mut cpSpace,
        func: cpSpaceShapeIteratorFunc,
        data: *mut libc::c_void,
    );
}
#[doc = " Space/constraint iterator callback function type."]
pub type cpSpaceConstraintIteratorFunc = ::core::option::Option<
    unsafe extern "C" fn(constraint: *mut cpConstraint, data: *mut libc::c_void),
>;
extern "C" {
    #[doc = " Call @c func for each shape in the space."]
    pub fn cpSpaceEachConstraint(
        space: *mut cpSpace,
        func: cpSpaceConstraintIteratorFunc,
        data: *mut libc::c_void,
    );
}
extern "C" {
    #[doc = " Update the collision detection info for the static shapes in the space."]
    pub fn cpSpaceReindexStatic(space: *mut cpSpace);
}
extern "C" {
    #[doc = " Update the collision detection data for a specific shape in the space."]
    pub fn cpSpaceReindexShape(space: *mut cpSpace, shape: *mut cpShape);
}
extern "C" {
    #[doc = " Update the collision detection data for all shapes attached to a body."]
    pub fn cpSpaceReindexShapesForBody(space: *mut cpSpace, body: *mut cpBody);
}
extern "C" {
    #[doc = " Switch the space to use a spatial has as it's spatial index."]
    pub fn cpSpaceUseSpatialHash(space: *mut cpSpace, dim: cpFloat, count: libc::c_int);
}
extern "C" {
    #[doc = " Step the space forward in time by @c dt."]
    pub fn cpSpaceStep(space: *mut cpSpace, dt: cpFloat);
}
#[doc = " Color type to use with the space debug drawing API."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cpSpaceDebugColor {
    pub r: f32,
    pub g: f32,
    pub b: f32,
    pub a: f32,
}
#[test]
fn bindgen_test_layout_cpSpaceDebugColor() {
    assert_eq!(
        ::core::mem::size_of::<cpSpaceDebugColor>(),
        16usize,
        concat!("Size of: ", stringify!(cpSpaceDebugColor))
    );
    assert_eq!(
        ::core::mem::align_of::<cpSpaceDebugColor>(),
        4usize,
        concat!("Alignment of ", stringify!(cpSpaceDebugColor))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cpSpaceDebugColor>())).r as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cpSpaceDebugColor),
            "::",
            stringify!(r)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cpSpaceDebugColor>())).g as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cpSpaceDebugColor),
            "::",
            stringify!(g)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cpSpaceDebugColor>())).b as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cpSpaceDebugColor),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cpSpaceDebugColor>())).a as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cpSpaceDebugColor),
            "::",
            stringify!(a)
        )
    );
}
#[doc = " Callback type for a function that draws a filled, stroked circle."]
pub type cpSpaceDebugDrawCircleImpl = ::core::option::Option<
    unsafe extern "C" fn(
        pos: cpVect,
        angle: cpFloat,
        radius: cpFloat,
        outlineColor: cpSpaceDebugColor,
        fillColor: cpSpaceDebugColor,
        data: cpDataPointer,
    ),
>;
#[doc = " Callback type for a function that draws a line segment."]
pub type cpSpaceDebugDrawSegmentImpl = ::core::option::Option<
    unsafe extern "C" fn(a: cpVect, b: cpVect, color: cpSpaceDebugColor, data: cpDataPointer),
>;
#[doc = " Callback type for a function that draws a thick line segment."]
pub type cpSpaceDebugDrawFatSegmentImpl = ::core::option::Option<
    unsafe extern "C" fn(
        a: cpVect,
        b: cpVect,
        radius: cpFloat,
        outlineColor: cpSpaceDebugColor,
        fillColor: cpSpaceDebugColor,
        data: cpDataPointer,
    ),
>;
#[doc = " Callback type for a function that draws a convex polygon."]
pub type cpSpaceDebugDrawPolygonImpl = ::core::option::Option<
    unsafe extern "C" fn(
        count: libc::c_int,
        verts: *const cpVect,
        radius: cpFloat,
        outlineColor: cpSpaceDebugColor,
        fillColor: cpSpaceDebugColor,
        data: cpDataPointer,
    ),
>;
#[doc = " Callback type for a function that draws a dot."]
pub type cpSpaceDebugDrawDotImpl = ::core::option::Option<
    unsafe extern "C" fn(size: cpFloat, pos: cpVect, color: cpSpaceDebugColor, data: cpDataPointer),
>;
#[doc = " Callback type for a function that returns a color for a given shape. This gives you an opportunity to color shapes based on how they are used in your engine."]
pub type cpSpaceDebugDrawColorForShapeImpl = ::core::option::Option<
    unsafe extern "C" fn(shape: *mut cpShape, data: cpDataPointer) -> cpSpaceDebugColor,
>;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum cpSpaceDebugDrawFlags {
    CP_SPACE_DEBUG_DRAW_SHAPES = 1,
    CP_SPACE_DEBUG_DRAW_CONSTRAINTS = 2,
    CP_SPACE_DEBUG_DRAW_COLLISION_POINTS = 4,
}
#[doc = " Struct used with cpSpaceDebugDraw() containing drawing callbacks and other drawing settings."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cpSpaceDebugDrawOptions {
    #[doc = " Function that will be invoked to draw circles."]
    pub drawCircle: cpSpaceDebugDrawCircleImpl,
    #[doc = " Function that will be invoked to draw line segments."]
    pub drawSegment: cpSpaceDebugDrawSegmentImpl,
    #[doc = " Function that will be invoked to draw thick line segments."]
    pub drawFatSegment: cpSpaceDebugDrawFatSegmentImpl,
    #[doc = " Function that will be invoked to draw convex polygons."]
    pub drawPolygon: cpSpaceDebugDrawPolygonImpl,
    #[doc = " Function that will be invoked to draw dots."]
    pub drawDot: cpSpaceDebugDrawDotImpl,
    #[doc = " Flags that request which things to draw (collision shapes, constraints, contact points)."]
    pub flags: cpSpaceDebugDrawFlags,
    #[doc = " Outline color passed to the drawing function."]
    pub shapeOutlineColor: cpSpaceDebugColor,
    #[doc = " Function that decides what fill color to draw shapes using."]
    pub colorForShape: cpSpaceDebugDrawColorForShapeImpl,
    #[doc = " Color passed to drawing functions for constraints."]
    pub constraintColor: cpSpaceDebugColor,
    #[doc = " Color passed to drawing functions for collision points."]
    pub collisionPointColor: cpSpaceDebugColor,
    #[doc = " User defined context pointer passed to all of the callback functions as the 'data' argument."]
    pub data: cpDataPointer,
}
#[test]
fn bindgen_test_layout_cpSpaceDebugDrawOptions() {
    assert_eq!(
        ::core::mem::size_of::<cpSpaceDebugDrawOptions>(),
        112usize,
        concat!("Size of: ", stringify!(cpSpaceDebugDrawOptions))
    );
    assert_eq!(
        ::core::mem::align_of::<cpSpaceDebugDrawOptions>(),
        8usize,
        concat!("Alignment of ", stringify!(cpSpaceDebugDrawOptions))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<cpSpaceDebugDrawOptions>())).drawCircle as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cpSpaceDebugDrawOptions),
            "::",
            stringify!(drawCircle)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<cpSpaceDebugDrawOptions>())).drawSegment as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cpSpaceDebugDrawOptions),
            "::",
            stringify!(drawSegment)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<cpSpaceDebugDrawOptions>())).drawFatSegment as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cpSpaceDebugDrawOptions),
            "::",
            stringify!(drawFatSegment)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<cpSpaceDebugDrawOptions>())).drawPolygon as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cpSpaceDebugDrawOptions),
            "::",
            stringify!(drawPolygon)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<cpSpaceDebugDrawOptions>())).drawDot as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cpSpaceDebugDrawOptions),
            "::",
            stringify!(drawDot)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cpSpaceDebugDrawOptions>())).flags as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cpSpaceDebugDrawOptions),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<cpSpaceDebugDrawOptions>())).shapeOutlineColor as *const _
                as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(cpSpaceDebugDrawOptions),
            "::",
            stringify!(shapeOutlineColor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<cpSpaceDebugDrawOptions>())).colorForShape as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(cpSpaceDebugDrawOptions),
            "::",
            stringify!(colorForShape)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<cpSpaceDebugDrawOptions>())).constraintColor as *const _
                as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(cpSpaceDebugDrawOptions),
            "::",
            stringify!(constraintColor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<cpSpaceDebugDrawOptions>())).collisionPointColor as *const _
                as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(cpSpaceDebugDrawOptions),
            "::",
            stringify!(collisionPointColor)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cpSpaceDebugDrawOptions>())).data as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(cpSpaceDebugDrawOptions),
            "::",
            stringify!(data)
        )
    );
}
extern "C" {
    #[doc = " Debug draw the current state of the space using the supplied drawing options."]
    pub fn cpSpaceDebugDraw(space: *mut cpSpace, options: *mut cpSpaceDebugDrawOptions);
}
extern "C" {
    #[doc = " Calculate the moment of inertia for a circle."]
    #[doc = " @c r1 and @c r2 are the inner and outer diameters. A solid circle has an inner diameter of 0."]
    pub fn cpMomentForCircle(m: cpFloat, r1: cpFloat, r2: cpFloat, offset: cpVect) -> cpFloat;
}
extern "C" {
    #[doc = " Calculate area of a hollow circle."]
    #[doc = " @c r1 and @c r2 are the inner and outer diameters. A solid circle has an inner diameter of 0."]
    pub fn cpAreaForCircle(r1: cpFloat, r2: cpFloat) -> cpFloat;
}
extern "C" {
    #[doc = " Calculate the moment of inertia for a line segment."]
    #[doc = " Beveling radius is not supported."]
    pub fn cpMomentForSegment(m: cpFloat, a: cpVect, b: cpVect, radius: cpFloat) -> cpFloat;
}
extern "C" {
    #[doc = " Calculate the area of a fattened (capsule shaped) line segment."]
    pub fn cpAreaForSegment(a: cpVect, b: cpVect, radius: cpFloat) -> cpFloat;
}
extern "C" {
    #[doc = " Calculate the moment of inertia for a solid polygon shape assuming it's center of gravity is at it's centroid. The offset is added to each vertex."]
    pub fn cpMomentForPoly(
        m: cpFloat,
        count: libc::c_int,
        verts: *const cpVect,
        offset: cpVect,
        radius: cpFloat,
    ) -> cpFloat;
}
extern "C" {
    #[doc = " Calculate the signed area of a polygon. A Clockwise winding gives positive area."]
    #[doc = " This is probably backwards from what you expect, but matches Chipmunk's the winding for poly shapes."]
    pub fn cpAreaForPoly(count: libc::c_int, verts: *const cpVect, radius: cpFloat) -> cpFloat;
}
extern "C" {
    #[doc = " Calculate the natural centroid of a polygon."]
    pub fn cpCentroidForPoly(count: libc::c_int, verts: *const cpVect) -> cpVect;
}
extern "C" {
    #[doc = " Calculate the moment of inertia for a solid box."]
    pub fn cpMomentForBox(m: cpFloat, width: cpFloat, height: cpFloat) -> cpFloat;
}
extern "C" {
    #[doc = " Calculate the moment of inertia for a solid box."]
    pub fn cpMomentForBox2(m: cpFloat, box_: cpBB) -> cpFloat;
}
extern "C" {
    #[doc = " Calculate the convex hull of a given set of points. Returns the count of points in the hull."]
    #[doc = " @c result must be a pointer to a @c cpVect array with at least @c count elements. If @c verts == @c result, then @c verts will be reduced inplace."]
    #[doc = " @c first is an optional pointer to an integer to store where the first vertex in the hull came from (i.e. verts[first] == result[0])"]
    #[doc = " @c tol is the allowed amount to shrink the hull when simplifying it. A tolerance of 0.0 creates an exact hull."]
    pub fn cpConvexHull(
        count: libc::c_int,
        verts: *const cpVect,
        result: *mut cpVect,
        first: *mut libc::c_int,
        tol: cpFloat,
    ) -> libc::c_int;
}
extern "C" {
    pub fn cpSpaceEachBody_b(space: *mut cpSpace, block: *mut libc::c_void);
}
extern "C" {
    pub fn cpSpaceEachShape_b(space: *mut cpSpace, block: *mut libc::c_void);
}
extern "C" {
    pub fn cpSpaceEachConstraint_b(space: *mut cpSpace, block: *mut libc::c_void);
}
extern "C" {
    pub fn cpBodyEachShape_b(body: *mut cpBody, block: *mut libc::c_void);
}
extern "C" {
    pub fn cpBodyEachConstraint_b(body: *mut cpBody, block: *mut libc::c_void);
}
extern "C" {
    pub fn cpBodyEachArbiter_b(body: *mut cpBody, block: *mut libc::c_void);
}
pub type cpSpacePointQueryBlock = *mut libc::c_void;
extern "C" {
    pub fn cpSpacePointQuery_b(
        space: *mut cpSpace,
        point: cpVect,
        maxDistance: cpFloat,
        filter: cpShapeFilter,
        block: cpSpacePointQueryBlock,
    );
}
pub type cpSpaceSegmentQueryBlock = *mut libc::c_void;
extern "C" {
    pub fn cpSpaceSegmentQuery_b(
        space: *mut cpSpace,
        start: cpVect,
        end: cpVect,
        radius: cpFloat,
        filter: cpShapeFilter,
        block: cpSpaceSegmentQueryBlock,
    );
}
pub type cpSpaceBBQueryBlock = *mut libc::c_void;
extern "C" {
    pub fn cpSpaceBBQuery_b(
        space: *mut cpSpace,
        bb: cpBB,
        filter: cpShapeFilter,
        block: cpSpaceBBQueryBlock,
    );
}
pub type cpSpaceShapeQueryBlock = *mut libc::c_void;
extern "C" {
    pub fn cpSpaceShapeQuery_b(
        space: *mut cpSpace,
        shape: *mut cpShape,
        block: cpSpaceShapeQueryBlock,
    ) -> cpBool;
}
